<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Ø¨Ù„ÙˆÚ©â€ŒÙ‡Ø§ + Ù…ØªØ±ÛŒØ§Ù„ + Undo/Redo + Ø®ÙˆØ±Ø´ÛŒØ¯ + Ù†Ù…Ø§Ù‡Ø§</title>
  <style>
    /* Ù¾Ø§ÛŒÙ‡ */
    html,body{margin:0;height:100%;overflow:hidden;background:#bcd2e8;color:#fff;font-family:sans-serif;}
    #canvas{width:100%;height:100%;display:block;}

    /* Ù†ÙˆØ§Ø± Ø§Ø¨Ø²Ø§Ø± Ø³Ù…Øª Ø±Ø§Ø³Øª (Ø¯Ø³Ú©ØªØ§Ù¾) - Ø¨Ø§Ø±ÛŒÚ©â€ŒØªØ± */
    #toolbar{
      position:absolute; right:.6rem; top:50%; transform:translateY(-50%);
      display:flex; flex-direction:column; gap:.5rem; width:220px; z-index:6;
    }
    .toolbtn{
      background:#5eead4; border:none; border-radius:999px; padding:.55rem .8rem;
      font-weight:700; color:#0b1020; box-shadow:0 8px 20px rgba(94,234,212,.2); cursor:pointer; font-size:.95rem;
    }
    .panel{
      background:#0f1220; border:1px solid #2b2f4a; border-radius:12px; padding:.5rem .55rem;
      box-shadow:0 8px 24px rgba(0,0,0,.12);
    }
    #blockList{
      width:100%; height:160px; background:#12162a; color:#e6edf3; border:1px solid #2b2f4a; border-radius:10px;
      padding:.25rem; outline:none; font-size:.92rem;
    }
    #renameRow{display:flex; gap:.35rem; margin-top:.4rem;}
    #renameInput{
      flex:1; border:1px solid #2b2f4a; border-radius:10px; background:#12162a; color:#e6edf3;
      padding:.35rem .5rem; outline:none; font-size:.92rem;
    }

    /* Ø­Ø§Ù„Øª Ø­Ø±Ú©Øª/Ú†Ø±Ø®Ø´ (Ø¨Ø§Ù„Ø§-Ø±Ø§Ø³Øª) */
    #modeToolbar{
      position:absolute; top:.55rem; right:.55rem; display:flex; gap:.35rem; z-index:7;
    }
    .modebtn{padding:.4rem .65rem; border-radius:10px; border:1px solid #2b2f4a; background:#171a2b; color:#e6edf3; font-size:.9rem;}

    /* Ù†ÙˆØ§Ø± Ù…ØªØ±ÛŒØ§Ù„ â€“ Ø¨Ø§Ù„Ø§-Ø±Ø§Ø³Øª (Ø¨Ø§Ø±ÛŒÚ©â€ŒØªØ±) */
    #materialBar{
      position:absolute; top:3.2rem; right:.55rem; z-index:7;
      display:flex; align-items:center; gap:.45rem;
      background:#0b1020; border:1px solid #5eead4; border-radius:12px; padding:.4rem .5rem;
      box-shadow:0 10px 28px rgba(0,0,0,.22);
    }
    #colorInput{-webkit-appearance:none;appearance:none;width:44px;height:30px;border:none;border-radius:8px;cursor:pointer;}
    #hexInput{width:96px;border:1px solid #2b2f4a;border-radius:8px;background:#12162a;color:#e6edf3;padding:.35rem .5rem;outline:none;font-family:monospace;font-size:.9rem;}
    #applyColorBtn{background:#5eead4;color:#0b1020;border:none;border-radius:999px;padding:.4rem .7rem;font-weight:700;cursor:pointer;box-shadow:0 8px 20px rgba(94,234,212,.22);font-size:.9rem;}

    /* Ù†ÙˆØ§Ø± Ø§Ù†ØªØ®Ø§Ø¨ Ù†ÙˆØ¹ Ø¨Ù„ÙˆÚ© â€“ Ú©Ù…ÛŒ Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ± Ø§Ø² Ù…ØªØ±ÛŒØ§Ù„ */
    #blockTypeBar{
      position:absolute; right:.55rem; top:6.2rem; z-index:7;
      display:flex; align-items:center; gap:.45rem;
      background:#0b1020; border:1px solid #2b2f4a; border-radius:12px;
      padding:.35rem .5rem; box-shadow:0 10px 28px rgba(0,0,0,.18);
      font-size:.9rem; color:#e6edf3;
    }
    #blockTypeBar label{color:#cbd5e1;}
    #blockTypeSel{
      background:#12162a; color:#e6edf3; border:1px solid #2b2f4a; border-radius:8px;
      padding:.28rem .45rem; outline:none; font-size:.9rem;
    }

    /* Undo/Redo Ø¨Ø§Ù„Ø§-Ú†Ù¾ */
    #historyBar{position:absolute; top:.55rem; left:.55rem; display:flex; gap:.35rem; z-index:7;}
    .histbtn{padding:.4rem .65rem; border-radius:10px; border:1px solid #2b2f4a; background:#171a2b; color:#e6edf3; cursor:pointer; box-shadow:0 6px 16px rgba(0,0,0,.12); font-size:.9rem;}
    .histbtn:disabled{opacity:.45; cursor:not-allowed;}

    /* Ù¾Ù†Ù„ Ú©Ù†ØªØ±Ù„ Ø®ÙˆØ±Ø´ÛŒØ¯ â€“ Ø³Ù…Øª Ú†Ù¾ (Ø¨Ø§Ø²/Ø¨Ø³ØªÙ‡) â€“ Ø¨Ø§Ø±ÛŒÚ©â€ŒØªØ± */
    #sunPanel{
      position:absolute; left:.55rem; top:50%; transform:translateY(-50%);
      width:220px; display:flex; flex-direction:column; gap:.35rem; z-index:6;
    }
    .sun-card{background:#0f1220;border:1px solid #2b2f4a;border-radius:12px;overflow:hidden;box-shadow:0 8px 24px rgba(0,0,0,.12);}
    .sun-header{display:flex;align-items:center;justify-content:space-between;gap:.6rem;padding:.5rem .6rem;cursor:pointer;user-select:none;}
    .sun-title{font-weight:700;}
    .sun-chevron{transition:transform .2s ease;}
    .sun-body{padding:.5rem .6rem;border-top:1px solid #2b2f4a;}
    .row{display:flex;align-items:center;gap:.5rem;margin-top:.3rem;}
    .row label{min-width:70px;color:#cbd5e1;font-size:.86rem;}
    .row input[type="range"]{flex:1;}
    .num{width:60px;border:1px solid #2b2f4a;border-radius:8px;background:#12162a;color:#e6edf3;padding:.3rem .45rem;outline:none;text-align:center;font-size:.9rem;}
    .presetbar{display:flex;gap:.35rem;margin-top:.35rem;flex-wrap:wrap;}
    .presetbar button{padding:.3rem .5rem;border-radius:8px;border:1px solid #2b2f4a;background:#171a2b;color:#e6edf3;cursor:pointer;font-size:.85rem;}
    .collapsed .sun-body{display:none;}
    .collapsed .sun-chevron{transform:rotate(180deg);}
    #sunOnOffBtn{
      padding:.3rem .6rem;border-radius:8px;border:1px solid #2b2f4a;background:#171a2b;color:#e6edf3;cursor:pointer;font-size:.85rem;
    }

    /* Ø¬Ù‡Øªâ€ŒÙ‡Ø§ÛŒ Ø¯ÙˆØ±Ø¨ÛŒÙ† â€“ Ø¨Ø§Ù„Ø§ÛŒ ÙˆØ³Ø· */
    #viewBar{position:absolute; top:.55rem; left:50%; transform:translateX(-50%); display:flex; gap:.35rem; z-index:7;}
    .viewbtn{padding:.4rem .65rem;border-radius:10px;border:1px solid #2b2f4a;background:#171a2b;color:#e6edf3;cursor:pointer;box-shadow:0 6px 16px rgba(0,0,0,.12);font-size:.9rem;}

    /* Ù†ÙˆØ§Ø± Ù…Ø®ØªØµØ§Øª Ø§Ù†ØªØ®Ø§Ø¨ (Ù¾ÛŒÙ„ Ú©ÙˆÚ†Ú©) */
    #coordsBar{
      position:absolute; bottom:5.2rem; left:.55rem; z-index:9;
      background:#0b1020; border:1px solid #2b2f4a; border-radius:999px; padding:.35rem .6rem; font-family:monospace; font-size:.9rem;
      box-shadow:0 6px 16px rgba(0,0,0,.12); opacity:.95;
    }

    /* -------------------- Ø±ÛŒØ³Ù¾Ø§Ù†Ø³ÛŒÙˆ -------------------- */
    @media (max-width: 768px){
      :root{--scale-small:.9;}

      #modeToolbar,#historyBar,#viewBar,#materialBar,#blockTypeBar{transform-origin:top right;}
      #modeToolbar{transform:scale(var(--scale-small)); right:.5rem; top:.5rem;}
      #historyBar{transform:scale(var(--scale-small)); left:.5rem; top:.5rem;}
      #viewBar{transform:translateX(-50%) scale(var(--scale-small)); top:.5rem;}
      #materialBar{transform:scale(var(--scale-small)); right:.5rem; top:3rem; gap:.35rem; padding:.35rem .45rem;}
      #blockTypeBar{right:.5rem; top:5.2rem; transform:scale(.9);}
      #colorInput{width:38px;height:28px;border-radius:8px;}
      #hexInput{width:84px;padding:.3rem .45rem;font-size:.85rem;}
      #applyColorBtn{padding:.35rem .6rem;font-size:.82rem;}

      #toolbar{
        position:fixed; left:calc(.5rem + env(safe-area-inset-left)); right:calc(.5rem + env(safe-area-inset-right));
        bottom:calc(.5rem + env(safe-area-inset-bottom)); top:auto; transform:none; width:auto;
        display:flex; flex-direction:row; align-items:stretch; gap:.45rem; z-index:10;
        backdrop-filter: blur(4px);
      }
      .toolbtn{padding:.45rem .6rem; font-size:.85rem; white-space:nowrap;}
      .panel{flex:1; padding:.4rem .45rem; border-radius:10px;}
      #blockList{height:84px; padding:.2rem; font-size:.85rem;}

      #sunPanel{width:180px; left:.5rem; top:auto; bottom:8.2rem; transform:none;}
      .row label{min-width:64px;}
      .num{width:56px;}

      #coordsBar{bottom:8.2rem; left:.5rem; font-size:.85rem; padding:.3rem .5rem;}
      .viewbtn,.modebtn,.histbtn{padding:.32rem .55rem; font-size:.82rem;}
    }

    @media (max-width:420px){
      #hexInput{width:76px;}
      #materialBar{top:2.8rem;}
    }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <canvas id="canvas"></canvas>

  <!-- Ø­Ø§Ù„Øª Ø­Ø±Ú©Øª/Ú†Ø±Ø®Ø´ (Ø¨Ø§Ù„Ø§-Ø±Ø§Ø³Øª) -->
  <div id="modeToolbar">
    <button id="modeMove" class="modebtn">Ø­Ø±Ú©Øª (T)</button>
    <button id="modeRotate" class="modebtn">Ú†Ø±Ø®Ø´ (R)</button>
  </div>

  <!-- Ù†ÙˆØ§Ø± Ù…ØªØ±ÛŒØ§Ù„ (Ø¨Ø§Ù„Ø§-Ø±Ø§Ø³Øª) -->
  <div id="materialBar">
    <input id="colorInput" type="color" value="#27e1c1" />
    <input id="hexInput" placeholder="#RRGGBB" value="#27e1c1" />
    <button id="applyColorBtn">Ø§Ø¹Ù…Ø§Ù„</button>
  </div>

  <!-- Ù†ÙˆØ§Ø± Ø§Ù†ØªØ®Ø§Ø¨ Ù†ÙˆØ¹ Ø¨Ù„ÙˆÚ© -->
  <div id="blockTypeBar">
    <label for="blockTypeSel">Ù†ÙˆØ¹ Ø¨Ù„ÙˆÚ©:</label>
    <select id="blockTypeSel">
      <option value="full">Ù…Ø¹Ù…ÙˆÙ„ÛŒ</option>
      <option value="noBottom">Ø¨Ø¯ÙˆÙ† Ú©Ù</option>
    </select>
  </div>

  <!-- Ù¾Ù†Ù„ Ú©Ù†ØªØ±Ù„ Ø®ÙˆØ±Ø´ÛŒØ¯ (Ø¬Ù…Ø¹â€ŒØ´ÙˆÙ†Ø¯Ù‡) -->
  <div id="sunPanel">
    <div class="sun-card" id="sunCard">
      <div class="sun-header" id="sunToggle">
        <div class="sun-title">Ù†ÙˆØ± Ø®ÙˆØ±Ø´ÛŒØ¯</div>
        <div class="sun-chevron">â–¾</div>
      </div>
      <div class="sun-body" id="sunBody">
        <div class="row">
          <label>Ø§Ø±ØªÙØ§Ø¹ (Â°)</label>
          <input id="elevRange" type="range" min="0" max="90" step="1">
          <input id="elevNum" class="num" type="number" min="0" max="90" step="1">
        </div>
        <div class="row">
          <label>Ø¢Ø²ÛŒÙ…ÙˆØª (Â°)</label>
          <input id="azRange" type="range" min="0" max="360" step="1">
          <input id="azNum" class="num" type="number" min="0" max="360" step="1">
        </div>
        <div class="row">
          <label>Ø®ÙˆØ±Ø´ÛŒØ¯</label>
          <button id="sunOnOffBtn">Ø®Ø§Ù…ÙˆØ´</button>
        </div>
        <div class="presetbar">
          <button data-e="10" data-a="90">ØµØ¨Ø­</button>
          <button data-e="60" data-a="180">Ø¸Ù‡Ø±</button>
          <button data-e="15" data-a="260">Ø¹ØµØ±</button>
          <button data-e="3"  data-a="300">ØºØ±ÙˆØ¨</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Ù†ÙˆØ§Ø± Ø§Ø¨Ø²Ø§Ø± (Ø¯Ø³Ú©ØªØ§Ù¾ Ø±Ø§Ø³Øª / Ù…ÙˆØ¨Ø§ÛŒÙ„ Ù¾Ø§ÛŒÛŒÙ†) -->
  <div id="toolbar">
    <button id="addBlockBtn" class="toolbtn">â• Ø§ÙØ²ÙˆØ¯Ù†</button>
    <button id="deleteBlockBtn" class="toolbtn" style="background:#f87171;color:#fff;">ğŸ—‘ï¸ Ø­Ø°Ù</button>

    <div class="panel">
      <div style="font-weight:700; margin-bottom:.35rem;">Ù„ÛŒØ³Øª Ø¨Ù„ÙˆÚ©â€ŒÙ‡Ø§</div>
      <select id="blockList" size="8"></select>
      <div id="renameRow">
        <input id="renameInput" placeholder="Ù†Ø§Ù… Ø¬Ø¯ÛŒØ¯..." />
        <button id="renameBtn" class="toolbtn" style="padding:.35rem .6rem;">ØªØºÛŒÛŒØ± Ù†Ø§Ù…</button>
      </div>
    </div>
  </div>

  <!-- Undo/Redo -->
  <div id="historyBar">
    <button id="undoBtn" class="histbtn" title="Ctrl+Z">â†¶ Undo</button>
    <button id="redoBtn" class="histbtn" title="Ctrl+Y">â†· Redo</button>
  </div>

  <!-- Ø¬Ù‡Øªâ€ŒÙ‡Ø§ÛŒ Ø¯ÙˆØ±Ø¨ÛŒÙ† -->
  <div id="viewBar">
    <button class="viewbtn" data-dir="north">â¬† Ø´Ù…Ø§Ù„</button>
    <button class="viewbtn" data-dir="south">â¬‡ Ø¬Ù†ÙˆØ¨</button>
    <button class="viewbtn" data-dir="east">â¡ Ø´Ø±Ù‚</button>
    <button class="viewbtn" data-dir="west">â¬… ØºØ±Ø¨</button>
  </div>

  <!-- Ù†ÙˆØ§Ø± Ù…Ø®ØªØµØ§Øª Ø§Ù†ØªØ®Ø§Ø¨ -->
  <div id="coordsBar" style="display:none;">X: 0.00 | Y: 0.00 | Z: 0.00</div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { TransformControls } from 'three/addons/controls/TransformControls.js';
    import { Sky } from 'three/addons/objects/Sky.js';

    /* Renderer */
    const renderer = new THREE.WebGLRenderer({canvas:document.getElementById('canvas'),antialias:true});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
    renderer.setSize(innerWidth,innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    const scene = new THREE.Scene();

    /* Sky + Sun */
    const sky = new Sky(); sky.scale.setScalar(10000); scene.add(sky);
    const sunVec = new THREE.Vector3();
    let elevDeg = 80, azimDeg = 45;

    const sunlight = new THREE.DirectionalLight(0xffffff, 1.1);
    sunlight.castShadow = true;
    sunlight.shadow.mapSize.set(2048,2048);
    sunlight.shadow.radius = 2;
    const SHADOW_EXTENT = 220;
    Object.assign(sunlight.shadow.camera,{
      left:-SHADOW_EXTENT,right:SHADOW_EXTENT,top:SHADOW_EXTENT,bottom:-SHADOW_EXTENT,near:1,far:800
    });
    sunlight.shadow.bias=-0.0002; sunlight.shadow.normalBias=0.02;
    scene.add(sunlight, sunlight.target);

    function setSunAngles(elev, azim){
      elevDeg = THREE.MathUtils.clamp(elev, 0, 90);
      azimDeg = ((azim%360)+360)%360;
      const phi = THREE.MathUtils.degToRad(90 - elevDeg);
      const theta = THREE.MathUtils.degToRad(azimDeg);
      sunVec.setFromSphericalCoords(1, phi, theta);
      const u = sky.material.uniforms;
      u.turbidity.value = 10; u.rayleigh.value = 2; u.mieCoefficient.value = 0.005; u.mieDirectionalG.value = 0.8;
      u.sunPosition.value.copy(sunVec);
      sunlight.position.copy(sunVec).multiplyScalar(120);
      sunlight.target.position.set(0,0,0); sunlight.target.updateMatrixWorld(true);
    }
    setSunAngles(elevDeg, azimDeg);

    const ambient = new THREE.AmbientLight(0xffffff, .25);
    scene.add(ambient);

    /* Camera + controls */
    const camera = new THREE.PerspectiveCamera(55,innerWidth/innerHeight,.1,2000);
    camera.position.set(10,10,10);
    const orbit = new OrbitControls(camera,renderer.domElement);
    orbit.enableDamping = true; orbit.target.set(0,0,0);

    /* Grid + ground */
    const grid = new THREE.GridHelper(300,300,0x77ffd0,0x283047); grid.material.transparent=true; grid.material.opacity=.35; scene.add(grid);
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(300,300), new THREE.MeshStandardMaterial({color:0xd0e0f0,roughness:1,metalness:0}));
    ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

    /* Block dims + Ù†ÙˆØ¹ Ø¨Ù„ÙˆÚ© */
    const OUT_L=5.98, OUT_W=1.20, OUT_H=3.09, WALL=0.225;
    let BLOCK_TYPE = 'full'; // full | noBottom

    const blockTypeSel = document.getElementById('blockTypeSel');
    blockTypeSel.addEventListener('change', ()=>{ BLOCK_TYPE = blockTypeSel.value; });

    function createHollowBlockFull(){
      const g=new THREE.Group(), m=new THREE.MeshStandardMaterial({color:0x27e1c1,metalness:.1,roughness:.4});
      const lw=new THREE.Mesh(new THREE.BoxGeometry(WALL,OUT_H,OUT_W),m); lw.position.set(-(OUT_L/2-WALL/2),0,0);
      const rw=lw.clone(); rw.position.x*=-1;
      const t=new THREE.Mesh(new THREE.BoxGeometry(OUT_L,WALL,OUT_W),m); t.position.y=(OUT_H/2-WALL/2);
      const b=t.clone(); b.position.y*=-1;
      [lw,rw,t,b].forEach(w=>{w.castShadow=true;w.receiveShadow=true;g.add(w)});
      return g;
    }

    function createHollowBlockNoBottom(){
      const g=new THREE.Group(), m=new THREE.MeshStandardMaterial({color:0x27e1c1,metalness:.1,roughness:.4});
      const lw=new THREE.Mesh(new THREE.BoxGeometry(WALL,OUT_H,OUT_W),m); lw.position.set(-(OUT_L/2-WALL/2),0,0);
      const rw=lw.clone(); rw.position.x*=-1;
      const t=new THREE.Mesh(new THREE.BoxGeometry(OUT_L,WALL,OUT_W),m); t.position.y=(OUT_H/2-WALL/2);
      [lw,rw,t].forEach(w=>{w.castShadow=true;w.receiveShadow=true;g.add(w)});
      return g;
    }

    function createHollowBlock(){
      return (BLOCK_TYPE === 'noBottom') ? createHollowBlockNoBottom() : createHollowBlockFull();
    }

    /* State */
    const blocks=[], blockMap=new Map(); let blockCounter=0, nextId=1;
    const EPS=1e-6, ALLOW_OVERLAP=0.02;

    /* Helpers */
    const getWorldBox=o=>new THREE.Box3().setFromObject(o);

    // resolveCollisions Ø¨Ø§ Ø§Ù…Ú©Ø§Ù† Ù†Ø§Ø¯ÛŒØ¯Ù‡ Ú¯Ø±ÙØªÙ† ÛŒÚ© Set (Ù…Ø«Ù„Ø§Ù‹ Ú¯Ø±ÙˆÙ‡ Ø§Ù†ØªØ®Ø§Ø¨â€ŒØ´Ø¯Ù‡)
    function resolveCollisions(o, ignoreSet=null){
      const maxIter = 6;
      let moved = false;

      for(let iter = 0; iter < maxIter; iter++){
        let fixedAny = false;

        const a = getWorldBox(o);
        const aCenter = a.getCenter(new THREE.Vector3());

        for(const other of blocks){
          if(other === o) continue;
          if(ignoreSet && ignoreSet.has(other)) continue;

          const b = getWorldBox(other);
          if(!a.intersectsBox(b)) continue;

          const overlapX = Math.min(a.max.x - b.min.x, b.max.x - a.min.x);
          const overlapY = Math.min(a.max.y - b.min.y, b.max.y - a.min.y);
          const overlapZ = Math.min(a.max.z - b.min.z, b.max.z - a.min.z);
          const minOverlap = Math.min(overlapX, overlapY, overlapZ);

          if(minOverlap <= ALLOW_OVERLAP + EPS) continue;

          let axis = 'x';
          if(minOverlap === overlapY) axis = 'y';
          else if(minOverlap === overlapZ) axis = 'z';

          const bCenter = b.getCenter(new THREE.Vector3());
          const delta = new THREE.Vector3();
          const extra = minOverlap - ALLOW_OVERLAP;

          if(axis === 'x'){
            const dir = (aCenter.x >= bCenter.x) ? 1 : -1;
            delta.x = dir * extra;
          }else if(axis === 'y'){
            const dir = (aCenter.y >= bCenter.y) ? 1 : -1;
            delta.y = dir * extra;
          }else{
            const dir = (aCenter.z >= bCenter.z) ? 1 : -1;
            delta.z = dir * extra;
          }

          o.position.add(delta);
          fixedAny = true;
          moved = true;
        }

        if(!fixedAny) break;
      }

      clampGround(o);
      return moved;
    }

    function clampGround(o){
      const box=getWorldBox(o);
      if(box.min.y<0){
        o.position.y+=(-box.min.y+EPS);
      }
      if(o.position.y<OUT_H/2){
        o.position.y=OUT_H/2;
      }
    }

    function savePrevTransform(o){ o.userData.prevPos=o.position.clone(); o.userData.prevQuat=o.quaternion.clone(); }
    function revertPrevTransform(o){ if(o.userData.prevPos) o.position.copy(o.userData.prevPos); if(o.userData.prevQuat) o.quaternion.copy(o.userData.prevQuat); }

    const SNAP_TOL=0.15;
    const overlaps1D=(a1,a2,b1,b2)=>a1<=b2 && a2>=b1;

    function snapToNeighbors(o){
      if(!o) return false;
      const a=getWorldBox(o), best={axis:null,dist:Infinity,delta:0};
      for(const other of blocks){
        if(other===o) continue;
        const b=getWorldBox(other);
        if(overlaps1D(a.min.y,a.max.y,b.min.y,b.max.y)&&overlaps1D(a.min.z,a.max.z,b.min.z,b.max.z)){
          const d1=Math.abs(a.min.x-b.max.x); if(d1<SNAP_TOL&&d1<best.dist) Object.assign(best,{axis:'x',dist:d1,delta:b.max.x-a.min.x});
          const d2=Math.abs(a.max.x-b.min.x); if(d2<SNAP_TOL&&d2<best.dist) Object.assign(best,{axis:'x',dist:d2,delta:b.min.x-a.max.x});
        }
        if(overlaps1D(a.min.y,a.max.y,b.min.y,b.max.y)&&overlaps1D(a.min.x,a.max.x,b.min.x,b.max.x)){
          const d3=Math.abs(a.min.z-b.max.z); if(d3<SNAP_TOL&&d3<best.dist) Object.assign(best,{axis:'z',dist:d3,delta:b.max.z-a.min.z});
          const d4=Math.abs(a.max.z-b.min.z); if(d4<SNAP_TOL&&d4<best.dist) Object.assign(best,{axis:'z',dist:d4,delta:b.min.z-a.max.z});
        }
        if(overlaps1D(a.min.x,a.max.x,b.min.x,b.max.x)&&overlaps1D(a.min.z,a.max.z,b.min.z,b.max.z)){
          const d5=Math.abs(a.min.y-b.max.y); if(d5<SNAP_TOL&&d5<best.dist) Object.assign(best,{axis:'y',dist:d5,delta:b.max.y-a.min.y});
          const d6=Math.abs(a.max.y-b.min.y); if(d6<SNAP_TOL&&d6<best.dist) Object.assign(best,{axis:'y',dist:d6,delta:b.min.y-a.max.y});
        }
      }
      if(best.axis){
        if(best.axis==='x') o.position.x += best.delta;
        if(best.axis==='y') o.position.y = Math.max(o.position.y + best.delta, OUT_H/2 + EPS);
        if(best.axis==='z') o.position.z += best.delta;

        resolveCollisions(o);
        clampGround(o);
        savePrevTransform(o);
        return true;
      }
      return false;
    }

    /* Ø§Ù†ØªØ®Ø§Ø¨ + ÙˆØ§ÛŒØ±ÙØ±ÛŒÙ… */
    let selected=null;
    const selectedBlocks = new Set();
    const multiPivot = new THREE.Object3D();
    scene.add(multiPivot);

    function addWireframe(target){
      target.traverse(c=>{
        if(c.isMesh && !c.getObjectByName('__wf__')){
          const egeo=new THREE.EdgesGeometry(c.geometry,1);
          const line=new THREE.LineSegments(egeo,new THREE.LineBasicMaterial({color:0xffcc00,transparent:true,opacity:1}));
          line.name='__wf__'; c.add(line);
        }
      });
    }
    function removeWireframe(target){
      if(!target) return;
      target.traverse(c=>{
        const wf=c.getObjectByName('__wf__');
        if(wf){ c.remove(wf); wf.geometry.dispose(); wf.material.dispose(); }
      });
    }

    const coordsBar=document.getElementById('coordsBar');
    function fmt(n){ return n.toFixed(2); }
    function updateCoords(o){
      if(!o){ coordsBar.style.display='none'; return; }
      const p=o.position;
      coordsBar.textContent=`X: ${fmt(p.x)} | Y: ${fmt(p.y)} | Z: ${fmt(p.z)}`;
      coordsBar.style.display='inline-block';
    }

    function selectObject(o, additive=false){
      if(!additive){
        selectedBlocks.forEach(b=>removeWireframe(b));
        selectedBlocks.clear();
      }

      if(o){
        if(additive && selectedBlocks.has(o)){
          removeWireframe(o);
          selectedBlocks.delete(o);
          selected = selectedBlocks.size ? [...selectedBlocks][selectedBlocks.size-1] : null;
        }else{
          selectedBlocks.add(o);
          addWireframe(o);
          selected = o;
        }
      }else{
        selected = null;
      }

      if(selectedBlocks.size > 1){
        const box = new THREE.Box3();
        selectedBlocks.forEach(b=>box.expandByObject(b));
        const center = new THREE.Vector3();
        box.getCenter(center);
        multiPivot.position.copy(center);
        tctrl.attach(multiPivot);
        blockList.value = selected ? selected.name||'' : '';
        renameInput.value = selected ? selected.name||'' : '';
        const hex = selected ? getBlockHexColor(selected) : '#27e1c1';
        colorInput.value = hex;
        hexInput.value = hex;
        updateCoords(multiPivot);
      }else if(selected){
        tctrl.attach(selected);
        blockList.value = selected.name||'';
        renameInput.value = selected.name||'';
        const hex = getBlockHexColor(selected);
        colorInput.value = hex;
        hexInput.value = hex;
        updateCoords(selected);
      }else{
        tctrl.detach();
        blockList.value = '';
        renameInput.value = '';
        updateCoords(null);
      }
    }

    /* Picking */
    const raycaster=new THREE.Raycaster(), pointer=new THREE.Vector2();
    const setPointer=e=>{const r=renderer.domElement.getBoundingClientRect(); pointer.set((e.clientX-r.left)/r.width*2-1, -((e.clientY-r.top)/r.height*2-1));};
    function pickBlock(){ raycaster.setFromCamera(pointer,camera); const hits=raycaster.intersectObjects(blocks,true); if(!hits.length) return null; let o=hits[0].object; while(o&&!blocks.includes(o)) o=o.parent; return o; }

    /* Transform controls */
    const tctrl=new TransformControls(camera,renderer.domElement);
    tctrl.setMode('translate');
    tctrl.setSpace('world');
    tctrl.setTranslationSnap(1.2);
    tctrl.setRotationSnap(THREE.MathUtils.degToRad(90));
    scene.add(tctrl);

    const btnMove=document.getElementById('modeMove'), btnRotate=document.getElementById('modeRotate');
    const updateUI=()=>{const isMove=tctrl.mode==='translate'; btnMove.style.borderColor=isMove?'#5eead4':'#2b2f4a'; btnRotate.style.borderColor=!isMove?'#5eead4':'#2b2f4a';};
    btnMove.onclick=()=>{tctrl.setMode('translate');updateUI();};
    btnRotate.onclick=()=>{tctrl.setMode('rotate');tctrl.setRotationSnap(THREE.MathUtils.degToRad(90));updateUI();};
    updateUI();
    tctrl.addEventListener('dragging-changed',e=>orbit.enabled=!e.value);

    // ÙÙ‚Ø· ÙˆÙ‚ØªÛŒ dragging=true Ù‡Ø³Øª Ú¯Ø±ÙˆÙ‡/Ø¨Ù„ÙˆÚ©â€ŒÙ‡Ø§ Ø±Ø§ Ø¬Ø§Ø¨Ù‡â€ŒØ¬Ø§ Ú©Ù†
    tctrl.addEventListener('change', ()=>{
      if (!tctrl.dragging) return;

      const o = tctrl.object;
      if(!o) return;

      const ignoreSet = (selectedBlocks.size > 1 ? selectedBlocks : null);

      if(tctrl.mode === 'translate'){
        let delta = new THREE.Vector3(0,0,0);
        if(o.userData.lastPosDuringDrag){
          delta.subVectors(o.position, o.userData.lastPosDuringDrag);
        }
        o.userData.lastPosDuringDrag = o.position.clone();

        if(o === multiPivot){
          if(delta.lengthSq() > 0 && selectedBlocks.size){
            selectedBlocks.forEach(b=>{
              b.position.add(delta);
              resolveCollisions(b, ignoreSet);
              clampGround(b);
            });
          }
        }else{
          resolveCollisions(o, ignoreSet);
          clampGround(o);

          if(delta.lengthSq() > 0 && selectedBlocks.size > 1){
            selectedBlocks.forEach(b=>{
              if(b === o) return;
              b.position.add(delta);
              resolveCollisions(b, ignoreSet);
              clampGround(b);
            });
          }
        }
      }else{
        resolveCollisions(o, ignoreSet);
        clampGround(o);
      }

      updateCoords(o === multiPivot ? multiPivot : o);
    });

    tctrl.addEventListener('mouseUp', ()=>{
      const o = tctrl.object; 
      if(!o) return;

      o.userData.lastPosDuringDrag = null;
      const ignoreSet = (selectedBlocks.size > 1 ? selectedBlocks : null);

      if(o === multiPivot){
        selectedBlocks.forEach(b=>{
          snapToNeighbors(b);
          resolveCollisions(b, ignoreSet);
          clampGround(b);
          savePrevTransform(b);
        });
        updateCoords(multiPivot);
      }else{
        snapToNeighbors(o);
        resolveCollisions(o, ignoreSet);
        clampGround(o);

        if(selectedBlocks.size > 1){
          selectedBlocks.forEach(b=>{
            if(b === o) return;
            snapToNeighbors(b);
            resolveCollisions(b, ignoreSet);
            clampGround(b);
            savePrevTransform(b);
          });
        }

        updateCoords(o);
        savePrevTransform(o);
      }
    });

    /* ØªØ§Ø±ÛŒØ®Ú†Ù‡ */
    const undoBtn=document.getElementById('undoBtn'), redoBtn=document.getElementById('redoBtn');
    const history=[], future=[];
    const pushAction=a=>{history.push(a); future.length=0; updateHistoryButtons();};
    const updateHistoryButtons=()=>{undoBtn.disabled=history.length===0; redoBtn.disabled=future.length===0;};
    const blockList=document.getElementById('blockList'), renameInput=document.getElementById('renameInput'), renameBtn=document.getElementById('renameBtn');

    function performAddFromState(state, selectAfter=true){
      const b=createHollowBlock(); b.name=state.name; b.userData.id=state.id; b.position.copy(state.pos); b.quaternion.copy(state.quat);
      setBlockColor(b, state.colorHex||'#27e1c1'); scene.add(b); blocks.push(b); blockMap.set(b.userData.id,b); addBlockToList(b); if(selectAfter) selectObject(b); return b;
    }
    const serializeBlock=b=>({id:b.userData.id,name:b.name,pos:b.position.clone(),quat:b.quaternion.clone(),colorHex:getBlockHexColor(b)});
    const cmdAddBlock=st=>performAddFromState(st,true);

    function cmdDeleteBlock(id){
      const b=findBlockById(id); if(!b) return;
      removeWireframe(b); scene.remove(b);
      const i=blocks.indexOf(b); if(i!==-1) blocks.splice(i,1);
      blockMap.delete(id); removeBlockFromList(b);
      if(selected===b) selectObject(null);
    }
    function cmdRename(id,newName){
      const b=findBlockById(id); if(!b) return;
      b.name=newName; updateBlockNameInList(id,newName);
      if(selected===b){ renameInput.value=newName; blockList.value=newName; }
    }
    function cmdTransform(id,pose){ const b=findBlockById(id); if(!b) return; b.position.copy(pose.pos); b.quaternion.copy(pose.quat); clampGround(b); updateCoords(b); }
    function cmdRecolor(id,colorHex){ const b=findBlockById(id); if(!b) return; setBlockColor(b,colorHex); if(selected===b){colorInput.value=colorHex; hexInput.value=colorHex;} }

    function undo(){
      const a=history.pop(); if(!a) return; future.push(a); updateHistoryButtons();
      switch(a.type){
        case'add':cmdDeleteBlock(a.state.id);break;
        case'delete':cmdAddBlock(a.state);break;
        case'rename':cmdRename(a.id,a.prevName);break;
        case'transform':cmdTransform(a.id,a.prev); if(selected&&selected.userData.id===a.id) selectObject(findBlockById(a.id)); break;
        case'recolor':cmdRecolor(a.id,a.prevHex);break;
      }
    }
    function redo(){
      const a=future.pop(); if(!a) return; history.push(a); updateHistoryButtons();
      switch(a.type){
        case'add':cmdAddBlock(a.state);break;
        case'delete':cmdDeleteBlock(a.state.id);break;
        case'rename':cmdRename(a.id,a.nextName);break;
        case'transform':cmdTransform(a.id,a.next); if(selected&&selected.userData.id===a.id) selectObject(findBlockById(a.id)); break;
        case'recolor':cmdRecolor(a.id,a.nextHex);break;
      }
    }
    undoBtn.onclick=undo; redoBtn.onclick=redo;
    window.addEventListener('keydown',e=>{
      if((e.ctrlKey||e.metaKey)&&e.key.toLowerCase()==='z'){e.preventDefault();undo();}
      if((e.ctrlKey||e.metaKey)&&e.key.toLowerCase()==='y'){e.preventDefault();redo();}
    });

    /* Ù„ÛŒØ³Øª Ù†Ø§Ù…â€ŒÙ‡Ø§ */
    function addBlockToList(block){
      const opt=document.createElement('option');
      opt.value=block.name; opt.textContent=block.name; opt.dataset.id=block.userData.id;
      blockList.appendChild(opt);
    }
    function removeBlockFromList(block){
      [...blockList.options].forEach(o=>{ if(+o.dataset.id===block.userData.id) o.remove(); });
    }
    function updateBlockNameInList(id,newName){
      [...blockList.options].forEach(o=>{ if(+o.dataset.id===id){o.value=newName;o.textContent=newName;} });
    }
    const findBlockById=id=>blockMap.get(id)||null;

    blockList.addEventListener('change',()=>{
      const opt=blockList.selectedOptions[0];
      if(!opt){selectObject(null);return;}
      const b=findBlockById(+opt.dataset.id); 
      selectObject(b||null, false);
    });

    /* Ø§ÙØ²ÙˆØ¯Ù†/Ø­Ø°Ù/ØªØºÛŒÛŒØ± Ù†Ø§Ù… */
    document.getElementById('addBlockBtn').onclick=()=>{
      const b=createHollowBlock();
      b.userData.id=nextId++;
      b.name=`Ø¨Ù„ÙˆÚ© ${++blockCounter}`;
      if(blocks.length===0){
        b.position.set(0,OUT_H/2,0);
      }else{
        const last=blocks[blocks.length-1], lb=getWorldBox(last);
        b.position.set(lb.max.x+(OUT_L/2), last.position.y, last.position.z);
      }
      setBlockColor(b, colorInput.value||'#27e1c1');
      scene.add(b); blocks.push(b); blockMap.set(b.userData.id,b);
      clampGround(b); savePrevTransform(b); addBlockToList(b); selectObject(b);
      pushAction({type:'add', state:serializeBlock(b)}); updateHistoryButtons();
    };

    document.getElementById('deleteBlockBtn').onclick=()=>{
      if(!selected){alert('Ø§Ø¨ØªØ¯Ø§ ÛŒÚ© Ø¨Ù„ÙˆÚ© Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.');return;}
      const st=serializeBlock(selected);
      cmdDeleteBlock(selected.userData.id);
      pushAction({type:'delete', state:st});
    };

    renameBtn.onclick=()=>{
      if(!selected){alert('Ø§Ø¨ØªØ¯Ø§ ÛŒÚ© Ø¨Ù„ÙˆÚ© Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.');return;}
      const id=selected.userData.id, prev=selected.name, next=(renameInput.value||'').trim();
      if(!next){alert('Ù†Ø§Ù… Ø¬Ø¯ÛŒØ¯ Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª.');return;}
      if(prev===next) return;
      cmdRename(id,next);
      pushAction({type:'rename', id, prevName:prev, nextName:next});
    };

    /* Ø§Ù†ØªØ®Ø§Ø¨ Ø¨Ø§ Ú©Ù„ÛŒÚ© (Ctrl Ø¨Ø±Ø§ÛŒ Ú†Ù†Ø¯Ø§Ù†ØªØ®Ø§Ø¨ÛŒ) */
    renderer.domElement.addEventListener('pointerdown',e=>{
      setPointer(e);
      if(tctrl.axis||tctrl.dragging) return;

      const hit = pickBlock();
      const additive = e.ctrlKey || e.metaKey;

      if(hit){
        selectObject(hit, additive);
      }else if(!additive){
        selectObject(null);
      }
    });

    /* Ú©Ù†ØªØ±Ù„â€ŒÙ‡Ø§ÛŒ Ø®ÙˆØ±Ø´ÛŒØ¯ */
    const elevRange=document.getElementById('elevRange'), elevNum=document.getElementById('elevNum'),
          azRange=document.getElementById('azRange'), azNum=document.getElementById('azNum');

    const syncSunInputs=()=>{elevRange.value=elevDeg; elevNum.value=elevDeg; azRange.value=azimDeg; azNum.value=azimDeg;};
    const onSunChange=()=>setSunAngles(+elevNum.value, +azNum.value);

    elevRange.addEventListener('input',()=>{elevNum.value=elevRange.value; onSunChange();});
    elevNum.addEventListener('change',()=>{elevRange.value=elevNum.value; onSunChange();});
    azRange.addEventListener('input',()=>{azNum.value=azRange.value; onSunChange();});
    azNum.addEventListener('change',()=>{azRange.value=azimDeg=azNum.value; onSunChange();});

    document.querySelectorAll('.presetbar button').forEach(btn=>{
      btn.addEventListener('click',()=>{
        setSunAngles(+btn.dataset.e, +btn.dataset.a);
        syncSunInputs();
      });
    });
    syncSunInputs();

    const sunOnOffBtn = document.getElementById('sunOnOffBtn');
    let sunEnabled = true;

    if(sunOnOffBtn){
      sunOnOffBtn.addEventListener('click', ()=>{
        sunEnabled = !sunEnabled;
        if(sunEnabled){
          sunlight.intensity = 1.1;
          ambient.intensity = 0.25;
          sunOnOffBtn.textContent = 'Ø®Ø§Ù…ÙˆØ´';
        }else{
          sunlight.intensity = 0.0;
          ambient.intensity = 1.0;
          sunOnOffBtn.textContent = 'Ø±ÙˆØ´Ù†';
        }
      });
    }

    const sunPanelEl=document.getElementById('sunPanel');
    const sunToggle=document.getElementById('sunToggle');
    const isMobile = window.matchMedia('(max-width: 768px)').matches;
    if (isMobile) sunPanelEl.classList.add('collapsed');
    sunToggle.addEventListener('click',()=>{ sunPanelEl.classList.toggle('collapsed'); });

    /* Ø¬Ù‡Øªâ€ŒÙ‡Ø§ÛŒ Ø¯ÙˆØ±Ø¨ÛŒÙ† */
    const viewBar=document.getElementById('viewBar');
    let camTween=null; const easeInOutQuad=t=>t<.5?2*t*t:-1+(4-2*t)*t;
    function flyCamera(toPos,toTarget,dur=600){
      const fromPos=camera.position.clone(), fromTgt=orbit.target.clone();
      camTween={t0:performance.now(),dur,fromPos,toPos,fromTgt,toTarget}; orbit.enabled=false;
    }
    function flyToDirection(dir){
      const tgt=orbit.target.clone(), dist=camera.position.distanceTo(tgt), h=Math.max(camera.position.y,6);
      const off=new THREE.Vector3(
        dir==='east'?dist:dir==='west'?-dist:0,
        h,
        dir==='north'?dist:dir==='south'?-dist:0
      );
      flyCamera(new THREE.Vector3().addVectors(tgt,off), tgt, 600);
    }
    viewBar.addEventListener('click',e=>{
      const btn=e.target.closest('button[data-dir]'); if(btn) flyToDirection(btn.dataset.dir);
    });

    /* Apply color */
    const colorInput=document.getElementById('colorInput'), hexInput=document.getElementById('hexInput'), applyColorBtn=document.getElementById('applyColorBtn');
    colorInput.addEventListener('input',()=>{hexInput.value=colorInput.value;});
    hexInput.addEventListener('change',()=>{
      const v=(hexInput.value||'').trim();
      if(/^#([0-9a-fA-F]{6})$/.test(v)) colorInput.value=v; else hexInput.value=colorInput.value;
    });
    function getBlockHexColor(block){
      let hex='#27e1c1';
      block.traverse(c=>{ if(c.isMesh&&c.material&&c.material.color) hex='#'+c.material.color.getHexString(); });
      return hex;
    }
    function setBlockColor(block, hex){
      const col=new THREE.Color(hex);
      block.traverse(c=>{ if(c.isMesh&&c.material){ c.material.color.copy(col); c.material.needsUpdate=true; } });
    }
    applyColorBtn.onclick=()=>{
      if(!selected){alert('Ø§Ø¨ØªØ¯Ø§ ÛŒÚ© Ø¨Ù„ÙˆÚ© Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.');return;}
      const id=selected.userData.id, prev=getBlockHexColor(selected), next=colorInput.value||'#27e1c1';
      if(prev.toLowerCase()===next.toLowerCase()) return;
      cmdRecolor(id,next); pushAction({type:'recolor', id, prevHex:prev, nextHex:next});
    };

    /* Resize + Loop */
    window.addEventListener('resize',()=>{
      camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(innerWidth,innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
    });
    function animate(){
      const now=performance.now();
      if(camTween){
        const k=Math.min(1,(now-camTween.t0)/camTween.dur), s=easeInOutQuad(k);
        camera.position.lerpVectors(camTween.fromPos,camTween.toPos,s);
        orbit.target.lerpVectors(camTween.fromTgt,camTween.toTarget,s);
        if(k>=1){camTween=null; orbit.enabled=true;}
      }
      orbit.update(); renderer.render(scene,camera); requestAnimationFrame(animate);
    }
    animate();
    updateHistoryButtons();
  </script>
</body>
</html>

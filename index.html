<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Ú†ÛŒØ¯Ù…Ø§Ù†Ø§</title>
  <style>
    /* Ù¾Ø§ÛŒÙ‡ */
    html,body{
      margin:0;
      height:100%;
      overflow:hidden;
      background:#bcd2e8;
      color:#fff;
      font-family:sans-serif;
    }
    #canvas{width:100%;height:100%;display:block;}

    /* Ù†ÙˆØ§Ø± Ø§Ø¨Ø²Ø§Ø± Ø³Ù…Øª Ø±Ø§Ø³Øª (Ø¯Ø³Ú©ØªØ§Ù¾) - Ø¨Ø§Ø±ÛŒÚ©â€ŒØªØ± */
    #toolbar{
      position:absolute;
      right:.6rem;
      top:50%;
      transform:translateY(-50%);
      display:flex;
      flex-direction:column;
      gap:.5rem;
      width:220px;
      z-index:6;
    }
    .toolbtn{
      background:#5eead4;
      border:none;
      border-radius:999px;
      padding:.55rem .8rem;
      font-weight:700;
      color:#0b1020;
      box-shadow:0 8px 20px rgba(94,234,212,.2);
      cursor:pointer;
      font-size:.95rem;
    }
    #toggleListBtn{display:none;} /* ÙÙ‚Ø· Ø¯Ø± Ø¯Ø³Ú©ØªØ§Ù¾ Ù…Ø®ÙÛŒØŒ Ø¯Ø± Ù…ÙˆØ¨Ø§ÛŒÙ„ Ù†Ø´ÙˆÙ† Ù…ÛŒâ€ŒØ¯ÛŒÙ… */
    .panel{
      background:#0f1220;
      border:1px solid #2b2f4a;
      border-radius:12px;
      padding:.5rem .55rem;
      box-shadow:0 8px 24px rgba(0,0,0,.12);
    }
    #blockList{
      width:100%;
      height:160px;
      background:#12162a;
      color:#e6edf3;
      border:1px solid #2b2f4a;
      border-radius:10px;
      padding:.25rem;
      outline:none;
      font-size:.92rem;
    }
    #renameRow{display:flex; gap:.35rem; margin-top:.4rem;}
    #renameInput{
      flex:1;
      border:1px solid #2b2f4a;
      border-radius:10px;
      background:#12162a;
      color:#e6edf3;
      padding:.35rem .5rem;
      outline:none;
      font-size:.92rem;
    }

    /* Ø­Ø§Ù„Øª Ø­Ø±Ú©Øª/Ú†Ø±Ø®Ø´ (Ø¨Ø§Ù„Ø§-Ø±Ø§Ø³Øª) */
    #modeToolbar{
      position:absolute;
      top:.55rem;
      right:.55rem;
      display:flex;
      gap:.35rem;
      z-index:7;
    }
    .modebtn{
      padding:.4rem .65rem;
      border-radius:10px;
      border:1px solid #2b2f4a;
      background:#171a2b;
      color:#e6edf3;
      font-size:.9rem;
    }

    /* Ù†ÙˆØ§Ø± Ù…ØªØ±ÛŒØ§Ù„ â€“ Ø¨Ø§Ù„Ø§-Ø±Ø§Ø³Øª (Ø¨Ø§Ø±ÛŒÚ©â€ŒØªØ±) */
    #materialBar{
      position:absolute;
      top:3.2rem;
      right:.55rem;
      z-index:7;
      display:flex;
      align-items:center;
      gap:.45rem;
      background:#0b1020;
      border:1px solid #5eead4;
      border-radius:12px;
      padding:.4rem .5rem;
      box-shadow:0 10px 28px rgba(0,0,0,.22);
    }
    #colorInput{
      -webkit-appearance:none;
      appearance:none;
      width:44px;
      height:30px;
      border:none;
      border-radius:8px;
      cursor:pointer;
    }
    #hexInput{
      width:96px;
      border:1px solid #2b2f4a;
      border-radius:8px;
      background:#12162a;
      color:#e6edf3;
      padding:.35rem .5rem;
      outline:none;
      font-family:monospace;
      font-size:.9rem;
    }
    #applyColorBtn{
      background:#5eead4;
      color:#0b1020;
      border:none;
      border-radius:999px;
      padding:.4rem .7rem;
      font-weight:700;
      cursor:pointer;
      box-shadow:0 8px 20px rgba(94,234,212,.22);
      font-size:.9rem;
    }

    /* Ù†ÙˆØ§Ø± Ø§Ù†ØªØ®Ø§Ø¨ Ù†ÙˆØ¹ Ø¨Ù„ÙˆÚ© â€“ Ú©Ù…ÛŒ Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ± Ø§Ø² Ù…ØªØ±ÛŒØ§Ù„ */
    #blockTypeBar{
      position:absolute;
      right:.55rem;
      top:6.2rem;
      z-index:7;
      display:flex;
      align-items:center;
      gap:.45rem;
      background:#0b1020;
      border:1px solid #2b2f4a;
      border-radius:12px;
      padding:.35rem .5rem;
      box-shadow:0 10px 28px rgba(0,0,0,.18);
      font-size:.9rem;
      color:#e6edf3;
    }
    #blockTypeBar label{color:#cbd5e1;}
    #blockTypeSel{
      background:#12162a;
      color:#e6edf3;
      border:1px solid #2b2f4a;
      border-radius:8px;
      padding:.28rem .45rem;
      outline:none;
      font-size:.9rem;
    }

    /* Undo/Redo Ø¨Ø§Ù„Ø§-Ú†Ù¾ */
    #historyBar{
      position:absolute;
      top:.55rem;
      left:.55rem;
      display:flex;
      gap:.35rem;
      z-index:7;
    }
    .histbtn{
      padding:.4rem .65rem;
      border-radius:10px;
      border:1px solid #2b2f4a;
      background:#171a2b;
      color:#e6edf3;
      cursor:pointer;
      box-shadow:0 6px 16px rgba(0,0,0,.12);
      font-size:.9rem;
    }
    .histbtn:disabled{opacity:.45; cursor:not-allowed;}

    /* Ù¾Ù†Ù„ Ú©Ù†ØªØ±Ù„ Ø®ÙˆØ±Ø´ÛŒØ¯ â€“ Ø³Ù…Øª Ú†Ù¾ (Ø¨Ø§Ø²/Ø¨Ø³ØªÙ‡) â€“ Ø¨Ø§Ø±ÛŒÚ©â€ŒØªØ± */
    #sunPanel{
      position:absolute;
      left:.55rem;
      top:50%;
      transform:translateY(-50%);
      width:220px;
      display:flex;
      flex-direction:column;
      gap:.35rem;
      z-index:6;
    }
    .sun-card{
      background:#0f1220;
      border:1px solid #2b2f4a;
      border-radius:12px;
      overflow:hidden;
      box-shadow:0 8px 24px rgba(0,0,0,.12);
    }
    .sun-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:.6rem;
      padding:.5rem .6rem;
      cursor:pointer;
      user-select:none;
    }
    .sun-title{font-weight:700;}
    .sun-chevron{transition:transform .2s ease;}
    .sun-body{
      padding:.5rem .6rem;
      border-top:1px solid #2b2f4a;
    }
    .row{
      display:flex;
      align-items:center;
      gap:.5rem;
      margin-top:.3rem;
    }
    .row label{
      min-width:70px;
      color:#cbd5e1;
      font-size:.86rem;
    }
    .row input[type="range"]{flex:1;}
    .num{
      width:60px;
      border:1px solid #2b2f4a;
      border-radius:8px;
      background:#12162a;
      color:#e6edf3;
      padding:.3rem .45rem;
      outline:none;
      text-align:center;
      font-size:.9rem;
    }
    .presetbar{
      display:flex;
      gap:.35rem;
      margin-top:.35rem;
      flex-wrap:wrap;
    }
    .presetbar button{
      padding:.3rem .5rem;
      border-radius:8px;
      border:1px solid #2b2f4a;
      background:#171a2b;
      color:#e6edf3;
      cursor:pointer;
      font-size:.85rem;
    }
    .collapsed .sun-body{display:none;}
    .collapsed .sun-chevron{transform:rotate(180deg);}
    #sunOnOffBtn{
      padding:.3rem .6rem;
      border-radius:8px;
      border:1px solid #2b2f4a;
      background:#171a2b;
      color:#e6edf3;
      cursor:pointer;
      font-size:.85rem;
    }

    /* Ø¬Ù‡Øªâ€ŒÙ‡Ø§ÛŒ Ø¯ÙˆØ±Ø¨ÛŒÙ† â€“ Ø¨Ø§Ù„Ø§ÛŒ ÙˆØ³Ø· (Ø¯Ø³Ú©ØªØ§Ù¾) */
    #viewBar{
      position:absolute;
      top:.55rem;
      left:50%;
      transform:translateX(-50%);
      display:flex;
      gap:.35rem;
      z-index:7;
    }
    .viewbtn{
      padding:.4rem .65rem;
      border-radius:10px;
      border:1px solid #2b2f4a;
      background:#171a2b;
      color:#e6edf3;
      cursor:pointer;
      box-shadow:0 6px 16px rgba(0,0,0,.12);
      font-size:.9rem;
    }

    /* Ù†ÙˆØ§Ø± Ù…Ø®ØªØµØ§Øª Ø§Ù†ØªØ®Ø§Ø¨ (Ù¾ÛŒÙ„ Ú©ÙˆÚ†Ú©) */
    #coordsBar{
      position:absolute;
      bottom:5.2rem;
      left:.55rem;
      z-index:9;
      background:#0b1020;
      border:1px solid #2b2f4a;
      border-radius:999px;
      padding:.35rem .6rem;
      font-family:monospace;
      font-size:.9rem;
      box-shadow:0 6px 16px rgba(0,0,0,.12);
      opacity:.95;
    }

    /* Ù†ÙˆØ§Ø± Ú©Ù†ØªØ±Ù„ Ù¾Ù„Ø§Ù† (Ù¾Ø§ÛŒÛŒÙ†-Ú†Ù¾) */
    #planToggleBar{
      position:absolute;
      bottom:.9rem;
      left:.9rem;
      z-index:11;
      display:flex;
      gap:.25rem;
      align-items:center;
    }
    #planToggleBtn,
    #planZoomIn,
    #planZoomOut{
      padding:.28rem .55rem;
      border-radius:999px;
      border:1px solid #2b2f4a;
      background:#0b1020;
      color:#e6edf3;
      font-size:.8rem;
      opacity:.9;
      cursor:pointer;
    }
    #planZoomIn,#planZoomOut{
      width:26px;
      text-align:center;
      padding:.2rem 0;
    }

    /* Ù†ÙˆØ§Ø± Ø§Ù†ØªØ®Ø§Ø¨ Ø·Ø¨Ù‚Ù‡ Ø¨Ø±Ø§ÛŒ Ù¾Ù„Ø§Ù† */
    #planFloorBar{
      position:absolute;
      bottom:3.2rem;
      left:.9rem;
      z-index:11;
      display:flex;
      gap:.3rem;
      align-items:center;
      background:#0b1020;
      border:1px solid #2b2f4a;
      border-radius:999px;
      padding:.25rem .6rem;
      font-size:.8rem;
      opacity:.9;
    }
    #planFloorBar select{
      background:#12162a;
      color:#e6edf3;
      border:1px solid #2b2f4a;
      border-radius:8px;
      padding:.15rem .35rem;
      font-size:.8rem;
      outline:none;
    }
    #planFloorLabel{
      font-size:.8rem;
      color:#cbd5e1;
    }

    /* -------------------- Ø±ÛŒØ³Ù¾Ø§Ù†Ø³ÛŒÙˆ -------------------- */
    @media (max-width: 768px){
      :root{--scale-small:.9;}

      #modeToolbar,#historyBar,#materialBar,#blockTypeBar{transform-origin:top right;}
      #modeToolbar{transform:scale(var(--scale-small)); right:.5rem; top:.5rem;}
      #historyBar{transform:scale(var(--scale-small)); left:.5rem; top:.5rem;}
      #materialBar{transform:scale(var(--scale-small)); right:.5rem; top:3rem; gap:.35rem; padding:.35rem .45rem;}
      #blockTypeBar{right:.5rem; top:5.2rem; transform:scale(.9);}
      #colorInput{width:38px;height:28px;border-radius:8px;}
      #hexInput{width:84px;padding:.3rem .45rem;font-size:.85rem;}
      #applyColorBtn{padding:.35rem .6rem;font-size:.82rem;}

      /* Ø¬Ù‡Øªâ€ŒÙ‡Ø§ÛŒ Ø¯ÙˆØ±Ø¨ÛŒÙ† â€“ Ù†Ø³Ø®Ù‡ Ù…ÙˆØ¨Ø§ÛŒÙ„: Ø³ØªÙˆÙ† Ø¯Ø± Ø³Ù…Øª Ø±Ø§Ø³Øª ØµÙØ­Ù‡ */
      #viewBar{
        right:.5rem;
        left:auto;
        top:8rem;
        transform:scale(var(--scale-small));
        flex-direction:column;
      }

      /* Ù†ÙˆØ§Ø± Ø§Ø¨Ø²Ø§Ø± Ù¾Ø§ÛŒÛŒÙ† Ù…ÙˆØ¨Ø§ÛŒÙ„ */
      #toolbar{
        position:fixed;
        left:calc(.5rem + env(safe-area-inset-left));
        right:calc(.5rem + env(safe-area-inset-right));
        bottom:calc(.5rem + env(safe-area-inset-bottom));
        top:auto;
        transform:none;
        width:auto;
        display:flex;
        flex-direction:row;
        align-items:stretch;
        gap:.45rem;
        z-index:10;
        backdrop-filter: blur(4px);
      }
      .toolbtn{padding:.45rem .6rem; font-size:.85rem; white-space:nowrap;}
      .panel{flex:1; padding:.4rem .45rem; border-radius:10px;}
      #blockList{height:84px; padding:.2rem; font-size:.85rem;}

      /* Ø¯Ú©Ù…Ù‡ Ù„ÛŒØ³Øª ÙÙ‚Ø· Ø¯Ø± Ù…ÙˆØ¨Ø§ÛŒÙ„ */
      #toggleListBtn{display:inline-block;}
      /* Ù¾ÛŒØ´â€ŒÙØ±Ø¶: Ù„ÛŒØ³Øª Ø¨Ø³ØªÙ‡ Ø¨Ø§Ø´Ø¯ØŒ JS Ø¨Ø§ Ú©Ù„ÛŒÚ© Ø¨Ø§Ø²Ø´ Ù…ÛŒâ€ŒÚ©Ù†Ø¯ */
      #blockPanel{display:none;}

      /* Ù¾Ù†Ù„ Ø®ÙˆØ±Ø´ÛŒØ¯: Ø¨Ø§Ù„Ø§ÛŒ Ø³Ù…Øª Ú†Ù¾ØŒ Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ø¨Ø³ØªÙ‡ (Ø¯Ø± JS) */
      #sunPanel{
        width:180px;
        left:.5rem;
        top:4.5rem;
        bottom:auto;
        transform:none;
      }
      .row label{min-width:64px;}
      .num{width:56px;}

      /* Ù†ÙˆØ§Ø± Ù…Ø®ØªØµØ§Øª Ø¨Ø§Ù„Ø§ÛŒ Ù†ÙˆØ§Ø± Ù¾Ø§ÛŒÛŒÙ† */
      #coordsBar{bottom:8.2rem; left:.5rem; font-size:.85rem; padding:.3rem .5rem;}
      .viewbtn,.modebtn,.histbtn{padding:.32rem .55rem; font-size:.82rem;}

      #planToggleBar{
        bottom:.6rem;
        left:.6rem;
      }
      #planFloorBar{
        bottom:3.6rem;
        left:.6rem;
      }
    }

    @media (max-width:420px){
      #hexInput{width:76px;}
      #materialBar{top:2.8rem;}
    }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <canvas id="canvas"></canvas>

  <!-- Ø­Ø§Ù„Øª Ø­Ø±Ú©Øª/Ú†Ø±Ø®Ø´ (Ø¨Ø§Ù„Ø§-Ø±Ø§Ø³Øª) -->
  <div id="modeToolbar">
    <button id="modeMove" class="modebtn">Ø­Ø±Ú©Øª (T)</button>
    <button id="modeRotate" class="modebtn">Ú†Ø±Ø®Ø´ (R)</button>
  </div>

  <!-- Ù†ÙˆØ§Ø± Ù…ØªØ±ÛŒØ§Ù„ (Ø¨Ø§Ù„Ø§-Ø±Ø§Ø³Øª) -->
  <div id="materialBar">
    <input id="colorInput" type="color" value="#27e1c1" />
    <input id="hexInput" placeholder="#RRGGBB" value="#27e1c1" />
    <button id="applyColorBtn">Ø§Ø¹Ù…Ø§Ù„</button>
  </div>

  <!-- Ù†ÙˆØ§Ø± Ø§Ù†ØªØ®Ø§Ø¨ Ù†ÙˆØ¹ Ø¨Ù„ÙˆÚ© -->
  <div id="blockTypeBar">
    <label for="blockTypeSel">Ù†ÙˆØ¹ Ø¨Ù„ÙˆÚ©:</label>
    <select id="blockTypeSel">
      <option value="full">Ù…Ø¹Ù…ÙˆÙ„ÛŒ</option>
      <option value="noBottom">Ø¨Ø¯ÙˆÙ† Ú©Ù</option>
    </select>
  </div>

  <!-- Ù¾Ù†Ù„ Ú©Ù†ØªØ±Ù„ Ø®ÙˆØ±Ø´ÛŒØ¯ (Ø¬Ù…Ø¹â€ŒØ´ÙˆÙ†Ø¯Ù‡) -->
  <div id="sunPanel">
    <div class="sun-card" id="sunCard">
      <div class="sun-header" id="sunToggle">
        <div class="sun-title">Ù†ÙˆØ± Ø®ÙˆØ±Ø´ÛŒØ¯</div>
        <div class="sun-chevron">â–¾</div>
      </div>
      <div class="sun-body" id="sunBody">
        <div class="row">
          <label>Ø§Ø±ØªÙØ§Ø¹ (Â°)</label>
          <input id="elevRange" type="range" min="0" max="90" step="1">
          <input id="elevNum" class="num" type="number" min="0" max="90" step="1">
        </div>
        <div class="row">
          <label>Ø¢Ø²ÛŒÙ…ÙˆØª (Â°)</label>
          <input id="azRange" type="range" min="0" max="360" step="1">
          <input id="azNum" class="num" type="number" min="0" max="360" step="1">
        </div>
        <div class="row">
          <label>Ø®ÙˆØ±Ø´ÛŒØ¯</label>
          <button id="sunOnOffBtn">Ø®Ø§Ù…ÙˆØ´</button>
        </div>
        <div class="presetbar">
          <button data-e="10" data-a="90">ØµØ¨Ø­</button>
          <button data-e="60" data-a="180">Ø¸Ù‡Ø±</button>
          <button data-e="15" data-a="260">Ø¹ØµØ±</button>
          <button data-e="3"  data-a="300">ØºØ±ÙˆØ¨</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Ù†ÙˆØ§Ø± Ø§Ø¨Ø²Ø§Ø± (Ø¯Ø³Ú©ØªØ§Ù¾ Ø±Ø§Ø³Øª / Ù…ÙˆØ¨Ø§ÛŒÙ„ Ù¾Ø§ÛŒÛŒÙ†) -->
  <div id="toolbar">
    <button id="addBlockBtn" class="toolbtn">â• Ø§ÙØ²ÙˆØ¯Ù†</button>
    <button id="deleteBlockBtn" class="toolbtn" style="background:#f87171;color:#fff;">ğŸ—‘ï¸ Ø­Ø°Ù</button>
    <button id="toggleListBtn" class="toolbtn">ğŸ“‹ Ù„ÛŒØ³Øª</button>

    <div class="panel" id="blockPanel">
      <div style="font-weight:700; margin-bottom:.35rem;">Ù„ÛŒØ³Øª Ø¨Ù„ÙˆÚ©â€ŒÙ‡Ø§</div>
      <select id="blockList" size="8"></select>
      <div id="renameRow">
        <input id="renameInput" placeholder="Ù†Ø§Ù… Ø¬Ø¯ÛŒØ¯..." />
        <button id="renameBtn" class="toolbtn" style="padding:.35rem .6rem;">ØªØºÛŒÛŒØ± Ù†Ø§Ù…</button>
      </div>
    </div>
  </div>

  <!-- Undo/Redo -->
  <div id="historyBar">
    <button id="undoBtn" class="histbtn" title="Ctrl+Z">â†¶ Undo</button>
    <button id="redoBtn" class="histbtn" title="Ctrl+Y">â†· Redo</button>
  </div>

  <!-- Ø¬Ù‡Øªâ€ŒÙ‡Ø§ÛŒ Ø¯ÙˆØ±Ø¨ÛŒÙ† + ÙˆØ§ÛŒØ±ÙØ±ÛŒÙ… -->
  <div id="viewBar">
    <button class="viewbtn" data-dir="north">â¬† Ø´Ù…Ø§Ù„</button>
    <button class="viewbtn" data-dir="south">â¬‡ Ø¬Ù†ÙˆØ¨</button>
    <button class="viewbtn" data-dir="east">â¡ Ø´Ø±Ù‚</button>
    <button class="viewbtn" data-dir="west">â¬… ØºØ±Ø¨</button>
    <button id="wireframeBtn" class="viewbtn">ÙˆØ§ÛŒØ±ÙØ±ÛŒÙ…</button>
  </div>

  <!-- Ù†ÙˆØ§Ø± Ù…Ø®ØªØµØ§Øª Ø§Ù†ØªØ®Ø§Ø¨ -->
  <div id="coordsBar" style="display:none;">X: 0.00 | Y: 0.00 | Z: 0.00</div>

  <!-- Ú©Ù†ØªØ±Ù„ Ù¾Ù„Ø§Ù† -->
  <div id="planToggleBar">
    <button id="planToggleBtn">ğŸ‘ Ù¾Ù„Ø§Ù† Ú©ÙˆÚ†Ú©</button>
    <button id="planZoomIn">+</button>
    <button id="planZoomOut">âˆ’</button>
  </div>

  <!-- Ø§Ù†ØªØ®Ø§Ø¨ Ø·Ø¨Ù‚Ù‡ Ø¨Ø±Ø§ÛŒ Ù¾Ù„Ø§Ù† -->
  <div id="planFloorBar">
    <span id="planFloorLabel">Ø·Ø¨Ù‚Ù‡:</span>
    <select id="planFloorSelect"></select>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { TransformControls } from 'three/addons/controls/TransformControls.js';
    import { Sky } from 'three/addons/objects/Sky.js';
    import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';

    /* Renderer */
    const renderer = new THREE.WebGLRenderer({
      canvas:document.getElementById('canvas'),
      antialias:true
    });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
    renderer.setSize(window.innerWidth,window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    const scene = new THREE.Scene();

    /* Sky + Sun */
    const sky = new Sky();
    sky.scale.setScalar(10000);
    scene.add(sky);
    const sunVec = new THREE.Vector3();
    let elevDeg = 80, azimDeg = 45;

    const sunlight = new THREE.DirectionalLight(0xffffff, 1.1);
    sunlight.castShadow = true;
    sunlight.shadow.mapSize.set(2048,2048);
    sunlight.shadow.radius = 2;
    const SHADOW_EXTENT = 220;
    Object.assign(sunlight.shadow.camera,{
      left:-SHADOW_EXTENT,
      right:SHADOW_EXTENT,
      top:SHADOW_EXTENT,
      bottom:-SHADOW_EXTENT,
      near:1,
      far:800
    });
    sunlight.shadow.bias=-0.0002;
    sunlight.shadow.normalBias=0.02;
    scene.add(sunlight, sunlight.target);

    function setSunAngles(elev, azim){
      elevDeg = THREE.MathUtils.clamp(elev, 0, 90);
      azimDeg = ((azim%360)+360)%360;
      const phi = THREE.MathUtils.degToRad(90 - elevDeg);
      const theta = THREE.MathUtils.degToRad(azimDeg);
      sunVec.setFromSphericalCoords(1, phi, theta);
      const u = sky.material.uniforms;
      u.turbidity.value = 10;
      u.rayleigh.value = 2;
      u.mieCoefficient.value = 0.005;
      u.mieDirectionalG.value = 0.8;
      u.sunPosition.value.copy(sunVec);
      sunlight.position.copy(sunVec).multiplyScalar(120);
      sunlight.target.position.set(0,0,0);
      sunlight.target.updateMatrixWorld(true);
    }
    setSunAngles(elevDeg, azimDeg);

    const ambient = new THREE.AmbientLight(0xffffff, .25);
    scene.add(ambient);

    /* Camera + controls Ø§ØµÙ„ÛŒ */
    const camera = new THREE.PerspectiveCamera(55,window.innerWidth/window.innerHeight,.1,2000);
    camera.position.set(10,10,10);
    const orbit = new OrbitControls(camera,renderer.domElement);
    orbit.enableDamping = true;
    orbit.target.set(0,0,0);

    /* Ø¯ÙˆØ±Ø¨ÛŒÙ† Ù¾Ù„Ø§Ù† Ø§Ø² Ø¨Ø§Ù„Ø§ (Orthographic) + Ø²ÙˆÙ… */
    const FRUSTUM_SIZE = 150;
    const PLAN_REL_SIZE = 0.23;  // Ù†Ø³Ø¨Øª Ù¾Ù„Ø§Ù† Ú©ÙˆÚ†Ú©
    const PLAN_MARGIN   = 12;    // Ø­Ø§Ø´ÛŒÙ‡ Ù¾Ù„Ø§Ù† Ú©ÙˆÚ†Ú©

    let planZoom = 3;
    const PLAN_ZOOM_MIN = 0.01;
    const PLAN_ZOOM_MAX = 1000;

    const planCamera = new THREE.OrthographicCamera(-1,1,1,-1,0.1,1000);
    planCamera.position.set(0,150,0);
    planCamera.up.set(0,0,-1);
    planCamera.lookAt(0,0,0);

    function updatePlanCameraFrustum(){
      const aspect = window.innerWidth / window.innerHeight;
      const size = FRUSTUM_SIZE / planZoom;
      planCamera.left   = -size * aspect / 2;
      planCamera.right  =  size * aspect / 2;
      planCamera.top    =  size / 2;
      planCamera.bottom = -size / 2;
      planCamera.updateProjectionMatrix();
    }
    function applyPlanZoom(newZoom){
      planZoom = THREE.MathUtils.clamp(newZoom, PLAN_ZOOM_MIN, PLAN_ZOOM_MAX);
      updatePlanCameraFrustum();
    }
    updatePlanCameraFrustum();

    /* Grid + ground */
    // 300 / 250 = 1.20 => Ø§Ù†Ø¯Ø§Ø²Ù‡ Ù‡Ø± Ù…Ø±Ø¨Ø¹ Ø±ÙˆÛŒ Ø²Ù…ÛŒÙ†
    const grid = new THREE.GridHelper(300, 250, 0x77ffd0, 0x283047);
    grid.material.transparent=true;
    grid.material.opacity=.35;
    scene.add(grid);
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(300,300),
      new THREE.MeshStandardMaterial({
        color:0xd0e0f0,
        roughness:1,
        metalness:0
      })
    );
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    /* Block dims + chamfer + Ù†ÙˆØ¹ Ø¨Ù„ÙˆÚ© + Ú¯Ø±ÛŒØ¯ */
    const OUT_L = 5.98,  // m
          OUT_W = 1.20,  // m
          OUT_H = 3.09,  // m
          WALL  = 0.225; // m

    const GRID_SIZE     = 1.20;         // Ø§Ù†Ø¯Ø§Ø²Ù‡ Ù‡Ø± Ø®Ø§Ù†Ù‡â€ŒÛŒ Ú¯Ø±ÛŒØ¯ X/Z
    const GRID_OFFSET_X = GRID_SIZE/2;  // 0.60 => Ù…Ø±Ú©Ø² Ø®Ø§Ù†Ù‡â€ŒÙ‡Ø§
    const GRID_OFFSET_Z = GRID_SIZE/2;  // 0.60 => Ù…Ø±Ú©Ø² Ø®Ø§Ù†Ù‡â€ŒÙ‡Ø§

    const GRID_Y_SIZE = OUT_H;          // 3.09 Ù…ØªØ±ØŒ Ú¯Ø§Ù… Ø¹Ù…ÙˆØ¯ÛŒ
    const GRID_Y_BASE = OUT_H / 2;      // 1.545 => Ù…Ø±Ú©Ø² Ø§ÙˆÙ„ÛŒÙ† Ø·Ø¨Ù‚Ù‡

    const CHAMFER = 0.02;               // 2 cm
    const CHAMFER_SEGMENTS = 2;

    let BLOCK_TYPE = 'full'; // full | noBottom
    let showPlanFull = false; // Ø¢ÛŒØ§ Ù¾Ù„Ø§Ù† ØªÙ…Ø§Ù…â€ŒØµÙØ­Ù‡ ÙØ¹Ø§Ù„ Ø§Ø³ØªØŸ
    let currentPlanFloor = 0; // Ø·Ø¨Ù‚Ù‡ ÙØ¹Ù„ÛŒ Ø¯Ø± Ù¾Ù„Ø§Ù†

    const blockTypeSel = document.getElementById('blockTypeSel');
    blockTypeSel.addEventListener('change', ()=>{ BLOCK_TYPE = blockTypeSel.value; });

    function createHollowBlockFull(){
      const g = new THREE.Group();
      const m = new THREE.MeshStandardMaterial({
        color: 0x27e1c1,
        metalness: 0.1,
        roughness: 0.4
      });

      // Ø¯ÛŒÙˆØ§Ø±Ù‡â€ŒÙ‡Ø§ÛŒ Ø·ÙˆÙ„ÛŒ (Ú†Ù¾ Ùˆ Ø±Ø§Ø³Øª) Ø¨Ø§ Ù¾Ø®ÛŒ
      const geoSide = new RoundedBoxGeometry(
        WALL,
        OUT_H,
        OUT_W,
        CHAMFER_SEGMENTS,
        CHAMFER
      );
      const lw = new THREE.Mesh(geoSide, m);
      lw.position.set(-(OUT_L/2 - WALL/2), 0, 0);
      lw.userData.isBlockPart = true;

      const rw = lw.clone();
      rw.position.x *= -1;
      rw.userData.isBlockPart = true;

      // Ø³Ù‚Ù Ùˆ Ú©Ù Ø¨Ø§ Ù¾Ø®ÛŒ
      const geoTopBottom = new RoundedBoxGeometry(
        OUT_L,
        WALL,
        OUT_W,
        CHAMFER_SEGMENTS,
        CHAMFER
      );
      const t = new THREE.Mesh(geoTopBottom, m);
      t.position.y = (OUT_H/2 - WALL/2);
      t.userData.hideInPlan  = true;
      t.userData.isBlockPart = true;

      const b = t.clone();
      b.position.y *= -1;
      b.userData.hideInPlan  = true;
      b.userData.isBlockPart = true;

      [lw, rw, t, b].forEach(w=>{
        w.castShadow = true;
        w.receiveShadow = true;
        g.add(w);
      });

      return g;
    }

    function createHollowBlockNoBottom(){
      const g = new THREE.Group();
      const m = new THREE.MeshStandardMaterial({
        color: 0x27e1c1,
        metalness: 0.1,
        roughness: 0.4
      });

      // Ø¯ÛŒÙˆØ§Ø±Ù‡â€ŒÙ‡Ø§ÛŒ Ø·ÙˆÙ„ÛŒ (Ú†Ù¾ Ùˆ Ø±Ø§Ø³Øª)
      const geoSide = new RoundedBoxGeometry(
        WALL,
        OUT_H,
        OUT_W,
        CHAMFER_SEGMENTS,
        CHAMFER
      );
      const lw = new THREE.Mesh(geoSide, m);
      lw.position.set(-(OUT_L/2 - WALL/2), 0, 0);
      lw.userData.isBlockPart = true;

      const rw = lw.clone();
      rw.position.x *= -1;
      rw.userData.isBlockPart = true;

      // ÙÙ‚Ø· Ø³Ù‚Ù (Ø¨Ø¯ÙˆÙ† Ú©Ù)
      const geoTop = new RoundedBoxGeometry(
        OUT_L,
        WALL,
        OUT_W,
        CHAMFER_SEGMENTS,
        CHAMFER
      );
      const t = new THREE.Mesh(geoTop, m);
      t.position.y = (OUT_H/2 - WALL/2);
      t.userData.hideInPlan  = true;
      t.userData.isBlockPart = true;

      [lw, rw, t].forEach(w=>{
        w.castShadow = true;
        w.receiveShadow = true;
        g.add(w);
      });

      return g;
    }

    function createHollowBlock(){
      return (BLOCK_TYPE === 'noBottom')
        ? createHollowBlockNoBottom()
        : createHollowBlockFull();
    }

    /* State */
    const blocks=[];
    const blockMap=new Map();
    let blockCounter=0, nextId=1;
    const EPS=1e-6, ALLOW_OVERLAP=0.02;

    const planFloorSelect = document.getElementById('planFloorSelect');

    /* Helpers */
    const getWorldBox=o=>new THREE.Box3().setFromObject(o);

    function getBlockFloorIndexFromY(y){
      return Math.round((y - GRID_Y_BASE) / GRID_Y_SIZE);
    }
    function getBlockFloorIndex(block){
      return getBlockFloorIndexFromY(block.position.y);
    }

    function resolveCollisions(o, ignoreSet=null){
      const maxIter = 6;
      let moved = false;

      for(let iter = 0; iter < maxIter; iter++){
        let fixedAny = false;

        const a = getWorldBox(o);
        const aCenter = a.getCenter(new THREE.Vector3());

        for(const other of blocks){
          if(other === o) continue;
          if(ignoreSet && ignoreSet.has(other)) continue;

          const b = getWorldBox(other);
          if(!a.intersectsBox(b)) continue;

          const overlapX = Math.min(a.max.x - b.min.x, b.max.x - a.min.x);
          const overlapY = Math.min(a.max.y - b.min.y, b.max.y - a.min.y);
          const overlapZ = Math.min(a.max.z - b.min.z, b.max.z - a.min.z);
          const minOverlap = Math.min(overlapX, overlapY, overlapZ);

          if(minOverlap <= ALLOW_OVERLAP + EPS) continue;

          let axis = 'x';
          if(minOverlap === overlapY) axis = 'y';
          else if(minOverlap === overlapZ) axis = 'z';

          const bCenter = b.getCenter(new THREE.Vector3());
          const delta = new THREE.Vector3();
          const extra = minOverlap - ALLOW_OVERLAP;

          if(axis === 'x'){
            const dir = (aCenter.x >= bCenter.x) ? 1 : -1;
            delta.x = dir * extra;
          }else if(axis === 'y'){
            const dir = (aCenter.y >= bCenter.y) ? 1 : -1;
            delta.y = dir * extra;
          }else{
            const dir = (aCenter.z >= bCenter.z) ? 1 : -1;
            delta.z = dir * extra;
          }

          o.position.add(delta);
          fixedAny = true;
          moved = true;
        }

        if(!fixedAny) break;
      }

      clampGround(o);
      return moved;
    }

    function clampGround(o){
      const box=getWorldBox(o);
      if(box.min.y<0){
        o.position.y+=(-box.min.y+EPS);
      }
      if(o.position.y<OUT_H/2){
        o.position.y=OUT_H/2;
      }
    }

    function savePrevTransform(o){
      o.userData.prevPos=o.position.clone();
      o.userData.prevQuat=o.quaternion.clone();
    }

    const SNAP_TOL=0.15;
    const overlaps1D=(a1,a2,b1,b2)=>a1<=b2 && a2>=b1;

    function snapToNeighbors(o){
      if(!o) return false;
      const a=getWorldBox(o);
      const best={axis:null,dist:Infinity,delta:0};

      for(const other of blocks){
        if(other===o) continue;
        const b=getWorldBox(other);

        // X
        if(overlaps1D(a.min.y,a.max.y,b.min.y,b.max.y) &&
           overlaps1D(a.min.z,a.max.z,b.min.z,b.max.z)){
          const d1=Math.abs(a.min.x-b.max.x);
          if(d1<SNAP_TOL&&d1<best.dist){
            best.axis='x'; best.dist=d1; best.delta=b.max.x-a.min.x;
          }
          const d2=Math.abs(a.max.x-b.min.x);
          if(d2<SNAP_TOL&&d2<best.dist){
            best.axis='x'; best.dist=d2; best.delta=b.min.x-a.max.x;
          }
        }

        // Z
        if(overlaps1D(a.min.y,a.max.y,b.min.y,b.max.y) &&
           overlaps1D(a.min.x,a.max.x,b.min.x,b.max.x)){
          const d3=Math.abs(a.min.z-b.max.z);
          if(d3<SNAP_TOL&&d3<best.dist){
            best.axis='z'; best.dist=d3; best.delta=b.max.z-a.min.z;
          }
          const d4=Math.abs(a.max.z-b.min.z);
          if(d4<SNAP_TOL&&d4<best.dist){
            best.axis='z'; best.dist=d4; best.delta=b.min.z-a.max.z;
          }
        }

        // Y
        if(overlaps1D(a.min.x,a.max.x,b.min.x,b.max.x) &&
           overlaps1D(a.min.z,a.max.z,b.min.z,b.max.z)){
          const d5=Math.abs(a.min.y-b.max.y);
          if(d5<SNAP_TOL&&d5<best.dist){
            best.axis='y'; best.dist=d5; best.delta=b.max.y-a.min.y;
          }
          const d6=Math.abs(a.max.y-b.min.y);
          if(d6<SNAP_TOL&&d6<best.dist){
            best.axis='y'; best.dist=d6; best.delta=b.min.y-a.max.y;
          }
        }
      }

      if(best.axis){
        if(best.axis==='x') o.position.x += best.delta;
        if(best.axis==='y') o.position.y = Math.max(o.position.y + best.delta, OUT_H/2 + EPS);
        if(best.axis==='z') o.position.z += best.delta;

        resolveCollisions(o);
        clampGround(o);
        savePrevTransform(o);
        return true;
      }
      return false;
    }

    /* Ø§Ø³Ù†Ù¾ Ø±ÙˆÛŒ Ú¯Ø±ÛŒØ¯ 1.20Ã—1.20 Ùˆ Ø·Ø¨Ù‚Ø§Øª Y=3.09 */
    function snapToGrid(o){
      if (!o) return;

      // X Ø±ÙˆÛŒ Ù…Ø±Ú©Ø² Ù…Ø±Ø¨Ø¹â€ŒÙ‡Ø§
      o.position.x =
        GRID_OFFSET_X +
        Math.round((o.position.x - GRID_OFFSET_X) / GRID_SIZE) * GRID_SIZE;

      // Z Ø±ÙˆÛŒ Ù…Ø±Ú©Ø² Ù…Ø±Ø¨Ø¹â€ŒÙ‡Ø§
      o.position.z =
        GRID_OFFSET_Z +
        Math.round((o.position.z - GRID_OFFSET_Z) / GRID_SIZE) * GRID_SIZE;

      // Y Ø±ÙˆÛŒ Ø·Ø¨Ù‚Ø§Øª Ø¨Ø§ Ú¯Ø§Ù… 3.09ØŒ Ù…Ø±Ú©Ø²: 1.545ØŒ 1.545+3.09ØŒ ...
      o.position.y =
        GRID_Y_BASE +
        Math.round((o.position.y - GRID_Y_BASE) / GRID_Y_SIZE) * GRID_Y_SIZE;
    }

    /* Ø§Ù†ØªØ®Ø§Ø¨ + ÙˆØ§ÛŒØ±ÙØ±ÛŒÙ… Ø§Ù†ØªØ®Ø§Ø¨ */
    let selected=null;
    const selectedBlocks = new Set();
    const multiPivot = new THREE.Object3D();
    scene.add(multiPivot);

    function addWireframe(target){
      target.traverse(c=>{
        if(c.isMesh && !c.getObjectByName('__wf__')){
          const egeo=new THREE.EdgesGeometry(c.geometry,1);
          const line=new THREE.LineSegments(
            egeo,
            new THREE.LineBasicMaterial({
              color:0xffcc00,
              transparent:true,
              opacity:1
            })
          );
          line.name='__wf__';
          c.add(line);
        }
      });
    }
    function removeWireframe(target){
      if(!target) return;
      target.traverse(c=>{
        const wf=c.getObjectByName('__wf__');
        if(wf){
          c.remove(wf);
          wf.geometry.dispose();
          wf.material.dispose();
        }
      });
    }

    const coordsBar=document.getElementById('coordsBar');
    function fmt(n){ return n.toFixed(2); }
    function updateCoords(o){
      if(!o){
        coordsBar.style.display='none';
        return;
      }
      const p=o.position;
      coordsBar.textContent=`X: ${fmt(p.x)} | Y: ${fmt(p.y)} | Z: ${fmt(p.z)}`;
      coordsBar.style.display='inline-block';
    }

    function selectObject(o, additive=false){
      if(!additive){
        selectedBlocks.forEach(b=>removeWireframe(b));
        selectedBlocks.clear();
      }

      if(o){
        if(additive && selectedBlocks.has(o)){
          removeWireframe(o);
          selectedBlocks.delete(o);
          selected = selectedBlocks.size ? [...selectedBlocks][selectedBlocks.size-1] : null;
        }else{
          selectedBlocks.add(o);
          addWireframe(o);
          selected = o;
        }
      }else{
        selected = null;
      }

      if(selectedBlocks.size > 1){
        const box = new THREE.Box3();
        selectedBlocks.forEach(b=>box.expandByObject(b));
        const center = new THREE.Vector3();
        box.getCenter(center);
        multiPivot.position.copy(center);
        if(!showPlanFull) tctrl.attach(multiPivot);
        blockList.value = selected ? (selected.name||'') : '';
        renameInput.value = selected ? (selected.name||'') : '';
        const hex = selected ? getBlockHexColor(selected) : '#27e1c1';
        colorInput.value = hex;
        hexInput.value = hex;
        updateCoords(multiPivot);
      }else if(selected){
        if(!showPlanFull) tctrl.attach(selected);
        blockList.value = selected.name||'';
        renameInput.value = selected.name||'';
        const hex = getBlockHexColor(selected);
        colorInput.value = hex;
        hexInput.value = hex;
        updateCoords(selected);
      }else{
        tctrl.detach();
        blockList.value = '';
        renameInput.value = '';
        updateCoords(null);
      }
    }

    /* Picking */
    const raycaster=new THREE.Raycaster();
    const pointer=new THREE.Vector2();
    const setPointer=e=>{
      const r=renderer.domElement.getBoundingClientRect();
      pointer.set(
        (e.clientX-r.left)/r.width*2-1,
        -((e.clientY-r.top)/r.height*2-1)
      );
    };
    function pickBlock(){
      raycaster.setFromCamera(pointer,camera);
      const hits=raycaster.intersectObjects(blocks,true);
      if(!hits.length) return null;
      let o=hits[0].object;
      while(o && !blocks.includes(o)) o=o.parent;
      return o;
    }

    /* Transform controls */
    const tctrl=new TransformControls(camera,renderer.domElement);
    tctrl.setMode('translate');
    tctrl.setSpace('world');
    tctrl.setTranslationSnap(null); // Ø§Ø³Ù†Ù¾ Ø¯Ø§Ø®Ù„ÛŒ Ø®Ø§Ù…ÙˆØ´ØŒ Ø®ÙˆØ¯Ù…ÙˆÙ† Ø¨Ø§ snapToGrid Ú©Ù†ØªØ±Ù„ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
    tctrl.setRotationSnap(THREE.MathUtils.degToRad(90));
    scene.add(tctrl);

    const btnMove=document.getElementById('modeMove');
    const btnRotate=document.getElementById('modeRotate');
    const updateUI=()=>{
      const isMove=tctrl.mode==='translate';
      btnMove.style.borderColor=isMove?'#5eead4':'#2b2f4a';
      btnRotate.style.borderColor=!isMove?'#5eead4':'#2b2f4a';
    };
    btnMove.onclick=()=>{tctrl.setMode('translate');updateUI();};
    btnRotate.onclick=()=>{
      tctrl.setMode('rotate');
      tctrl.setRotationSnap(THREE.MathUtils.degToRad(90));
      updateUI();
    };
    updateUI();
    tctrl.addEventListener('dragging-changed',e=>orbit.enabled=!e.value);

    /* Ø§Ù†ÛŒÙ…ÛŒØ´Ù† Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§Ù‡Ø§ */
    let camTween=null;
    const easeInOutQuad=t=>t<.5?2*t*t:-1+(4-2*t)*t;

    tctrl.addEventListener('change', ()=>{
      if (!tctrl.dragging) return;
      if (showPlanFull) return;

      const o = tctrl.object;
      if (!o) return;

      const ignoreSet = (selectedBlocks.size > 1 ? selectedBlocks : null);

      if (tctrl.mode === 'translate') {
        // --- Ø­Ø±Ú©Øª Ø±ÙˆÛŒ Ú¯Ø±ÛŒØ¯ ---

        if (!o.userData.lastPosDuringDrag) {
          o.userData.lastPosDuringDrag = o.position.clone();
          snapToGrid(o);
          o.userData.lastPosDuringDrag.copy(o.position);
        }

        snapToGrid(o);

        const delta = new THREE.Vector3().subVectors(
          o.position,
          o.userData.lastPosDuringDrag
        );
        o.userData.lastPosDuringDrag.copy(o.position);

        if (o === multiPivot) {
          if (delta.lengthSq() > 0 && selectedBlocks.size) {
            selectedBlocks.forEach(b=>{
              b.position.add(delta);
              resolveCollisions(b, ignoreSet);
              clampGround(b);
              snapToGrid(b);
            });
          }
        } else {
          resolveCollisions(o, ignoreSet);
          clampGround(o);
          snapToGrid(o);

          if (delta.lengthSq() > 0 && selectedBlocks.size > 1) {
            selectedBlocks.forEach(b=>{
              if (b === o) return;
              b.position.add(delta);
              resolveCollisions(b, ignoreSet);
              clampGround(b);
              snapToGrid(b);
            });
          }
        }

        updateCoords(o === multiPivot ? multiPivot : o);
      } else {
        resolveCollisions(o, ignoreSet);
        clampGround(o);
        updateCoords(o === multiPivot ? multiPivot : o);
      }
    });

    tctrl.addEventListener('mouseUp', ()=>{
      if (showPlanFull) return;
      const o = tctrl.object; 
      if(!o) return;

      o.userData.lastPosDuringDrag = null;
      const ignoreSet = (selectedBlocks.size > 1 ? selectedBlocks : null);

      if(o === multiPivot){
        selectedBlocks.forEach(b=>{
          snapToNeighbors(b);
          resolveCollisions(b, ignoreSet);
          clampGround(b);
          snapToGrid(b);
          savePrevTransform(b);
        });
        updateCoords(multiPivot);
      }else{
        snapToNeighbors(o);
        resolveCollisions(o, ignoreSet);
        clampGround(o);
        snapToGrid(o);

        if(selectedBlocks.size > 1){
          selectedBlocks.forEach(b=>{
            if(b === o) return;
            snapToNeighbors(b);
            resolveCollisions(b, ignoreSet);
            clampGround(b);
            snapToGrid(b);
            savePrevTransform(b);
          });
        }

        updateCoords(o);
        savePrevTransform(o);
      }

      refreshPlanFloors();
    });

    /* ØªØ§Ø±ÛŒØ®Ú†Ù‡ */
    const undoBtn=document.getElementById('undoBtn');
    const redoBtn=document.getElementById('redoBtn');
    const history=[];
    const future=[];
    const pushAction=a=>{
      history.push(a);
      future.length=0;
      updateHistoryButtons();
    };
    const updateHistoryButtons=()=>{
      undoBtn.disabled=history.length===0;
      redoBtn.disabled=future.length===0;
    };
    const blockList=document.getElementById('blockList');
    const renameInput=document.getElementById('renameInput');
    const renameBtn=document.getElementById('renameBtn');

    function performAddFromState(state, selectAfter=true){
      const b=createHollowBlock();
      b.name=state.name;
      b.userData.id=state.id;
      b.position.copy(state.pos);
      b.quaternion.copy(state.quat);
      setBlockColor(b, state.colorHex||'#27e1c1');
      scene.add(b);
      blocks.push(b);
      blockMap.set(b.userData.id,b);
      addBlockToList(b);
      if(selectAfter) selectObject(b);
      return b;
    }
    const serializeBlock=b=>({
      id:b.userData.id,
      name:b.name,
      pos:b.position.clone(),
      quat:b.quaternion.clone(),
      colorHex:getBlockHexColor(b)
    });
    const cmdAddBlock=st=>performAddFromState(st,true);

    function cmdDeleteBlock(id){
      const b=findBlockById(id);
      if(!b) return;
      removeWireframe(b);
      scene.remove(b);
      const i=blocks.indexOf(b);
      if(i!==-1) blocks.splice(i,1);
      blockMap.delete(id);
      removeBlockFromList(b);
      if(selected===b) selectObject(null);
      refreshPlanFloors();
    }
    function cmdRename(id,newName){
      const b=findBlockById(id);
      if(!b) return;
      b.name=newName;
      updateBlockNameInList(id,newName);
      if(selected===b){
        renameInput.value=newName;
        blockList.value=newName;
      }
    }
    function cmdTransform(id,pose){
      const b=findBlockById(id);
      if(!b) return;
      b.position.copy(pose.pos);
      b.quaternion.copy(pose.quat);
      clampGround(b);
      updateCoords(b);
    }
    function cmdRecolor(id,colorHex){
      const b=findBlockById(id);
      if(!b) return;
      setBlockColor(b,colorHex);
      if(selected===b){
        colorInput.value=colorHex;
        hexInput.value=colorHex;
      }
    }

    function undo(){
      const a=history.pop();
      if(!a) return;
      future.push(a);
      updateHistoryButtons();
      switch(a.type){
        case'add':
          cmdDeleteBlock(a.state.id);
          break;
        case'delete':
          cmdAddBlock(a.state);
          break;
        case'rename':
          cmdRename(a.id,a.prevName);
          break;
        case'transform':
          cmdTransform(a.id,a.prev);
          if(selected&&selected.userData.id===a.id)
            selectObject(findBlockById(a.id));
          break;
        case'recolor':
          cmdRecolor(a.id,a.prevHex);
          break;
      }
      refreshPlanFloors();
    }
    function redo(){
      const a=future.pop();
      if(!a) return;
      history.push(a);
      updateHistoryButtons();
      switch(a.type){
        case'add':
          cmdAddBlock(a.state);
          break;
        case'delete':
          cmdDeleteBlock(a.state.id);
          break;
        case'rename':
          cmdRename(a.id,a.nextName);
          break;
        case'transform':
          cmdTransform(a.id,a.next);
          if(selected&&selected.userData.id===a.id)
            selectObject(findBlockById(a.id));
          break;
        case'recolor':
          cmdRecolor(a.id,a.nextHex);
          break;
      }
      refreshPlanFloors();
    }
    undoBtn.onclick=undo;
    redoBtn.onclick=redo;
    window.addEventListener('keydown',e=>{
      if((e.ctrlKey||e.metaKey)&&e.key.toLowerCase()==='z'){
        e.preventDefault();undo();
      }
      if((e.ctrlKey||e.metaKey)&&e.key.toLowerCase()==='y'){
        e.preventDefault();redo();
      }
    });

    /* Ù„ÛŒØ³Øª Ù†Ø§Ù…â€ŒÙ‡Ø§ */
    function addBlockToList(block){
      const opt=document.createElement('option');
      opt.value=block.name;
      opt.textContent=block.name;
      opt.dataset.id=block.userData.id;
      blockList.appendChild(opt);
    }
    function removeBlockFromList(block){
      [...blockList.options].forEach(o=>{
        if(+o.dataset.id===block.userData.id) o.remove();
      });
    }
    function updateBlockNameInList(id,newName){
      [...blockList.options].forEach(o=>{
        if(+o.dataset.id===id){
          o.value=newName;
          o.textContent=newName;
        }
      });
    }
    const findBlockById=id=>blockMap.get(id)||null;

    blockList.addEventListener('change',()=>{
      const opt=blockList.selectedOptions[0];
      if(!opt){
        selectObject(null);
        return;
      }
      const b=findBlockById(+opt.dataset.id);
      selectObject(b||null,false);
    });

    /* Ø§ÙØ²ÙˆØ¯Ù†/Ø­Ø°Ù/ØªØºÛŒÛŒØ± Ù†Ø§Ù… */
    document.getElementById('addBlockBtn').onclick=()=>{
      const b=createHollowBlock();
      b.userData.id=nextId++;
      b.name=`Ø¨Ù„ÙˆÚ© ${++blockCounter}`;
      if(blocks.length===0){
        // Ø§ÙˆÙ„ÛŒÙ† Ø¨Ù„ÙˆÚ©
        b.position.set(2.99, 1.54, 0.60);
      }else{
        // Ø¨Ù‚ÛŒÙ‡ Ø¨Ù„ÙˆÚ©â€ŒÙ‡Ø§ Ú©Ù†Ø§Ø± Ø¢Ø®Ø±ÛŒÙ† Ø¨Ù„ÙˆÚ©
        const last=blocks[blocks.length-1];
        const lb=getWorldBox(last);
        b.position.set(lb.max.x+(OUT_L/2), last.position.y, last.position.z);
      }
      setBlockColor(b, colorInput.value||'#27e1c1');
      scene.add(b);
      blocks.push(b);
      blockMap.set(b.userData.id,b);
      clampGround(b);
      snapToGrid(b);
      savePrevTransform(b);
      addBlockToList(b);
      selectObject(b);
      pushAction({type:'add', state:serializeBlock(b)});
      updateHistoryButtons();
      refreshPlanFloors();
    };

    document.getElementById('deleteBlockBtn').onclick=()=>{
      if(!selected){
        alert('Ø§Ø¨ØªØ¯Ø§ ÛŒÚ© Ø¨Ù„ÙˆÚ© Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.');
        return;
      }
      const st=serializeBlock(selected);
      cmdDeleteBlock(selected.userData.id);
      pushAction({type:'delete', state:st});
      refreshPlanFloors();
    };

    renameBtn.onclick=()=>{
      if(!selected){
        alert('Ø§Ø¨ØªØ¯Ø§ ÛŒÚ© Ø¨Ù„ÙˆÚ© Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.');
        return;
      }
      const id=selected.userData.id;
      const prev=selected.name;
      const next=(renameInput.value||'').trim();
      if(!next){
        alert('Ù†Ø§Ù… Ø¬Ø¯ÛŒØ¯ Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª.');
        return;
      }
      if(prev===next) return;
      cmdRename(id,next);
      pushAction({type:'rename', id, prevName:prev, nextName:next});
    };

    /* Ø¨Ø§Ø² Ùˆ Ø¨Ø³ØªÙ‡â€ŒÚ©Ø±Ø¯Ù† Ù„ÛŒØ³Øª Ø¨Ù„ÙˆÚ©â€ŒÙ‡Ø§ Ø¯Ø± Ù…ÙˆØ¨Ø§ÛŒÙ„ */
    const blockPanel = document.getElementById('blockPanel');
    const toggleListBtn = document.getElementById('toggleListBtn');
    if (toggleListBtn && blockPanel){
      const isMobileList = window.matchMedia('(max-width: 768px)').matches;
      if(isMobileList){
        blockPanel.style.display = 'none';
      }
      toggleListBtn.addEventListener('click', ()=>{
        const hidden = blockPanel.style.display === 'none';
        blockPanel.style.display = hidden ? 'block' : 'none';
      });
    }

    /* Ø§Ù†ØªØ®Ø§Ø¨ Ø¨Ø§ Ú©Ù„ÛŒÚ© (Ctrl Ø¨Ø±Ø§ÛŒ Ú†Ù†Ø¯Ø§Ù†ØªØ®Ø§Ø¨ÛŒ) */
    renderer.domElement.addEventListener('pointerdown',e=>{
      if (showPlanFull) return; // Ø¯Ø± Ù¾Ù„Ø§Ù† ØªÙ…Ø§Ù…â€ŒØµÙØ­Ù‡ØŒ Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ú©Ù†ÛŒÙ…

      setPointer(e);
      if(tctrl.axis||tctrl.dragging) return;

      const hit = pickBlock();
      const additive = e.ctrlKey || e.metaKey;

      if(hit){
        selectObject(hit, additive);
      }else if(!additive){
        selectObject(null);
      }
    });

    /* Ú©Ù†ØªØ±Ù„â€ŒÙ‡Ø§ÛŒ Ø®ÙˆØ±Ø´ÛŒØ¯ */
    const elevRange=document.getElementById('elevRange');
    const elevNum=document.getElementById('elevNum');
    const azRange=document.getElementById('azRange');
    const azNum=document.getElementById('azNum');

    const syncSunInputs=()=>{
      elevRange.value=elevDeg;
      elevNum.value=elevDeg;
      azRange.value=azimDeg;
      azNum.value=azimDeg;
    };
    const onSunChange=()=>setSunAngles(+elevNum.value, +azNum.value);

    elevRange.addEventListener('input',()=>{
      elevNum.value=elevRange.value;
      onSunChange();
    });
    elevNum.addEventListener('change',()=>{
      elevRange.value=elevNum.value;
      onSunChange();
    });
    azRange.addEventListener('input',()=>{
      azNum.value=azRange.value;
      onSunChange();
    });
    azNum.addEventListener('change',()=>{
      azRange.value=azNum.value;
      onSunChange();
    });

    document.querySelectorAll('.presetbar button').forEach(btn=>{
      btn.addEventListener('click',()=>{
        setSunAngles(+btn.dataset.e, +btn.dataset.a);
        syncSunInputs();
      });
    });
    syncSunInputs();

    const sunOnOffBtn = document.getElementById('sunOnOffBtn');
let sunEnabled = false; // â¬… Ø§Ø² Ø§ÙˆÙ„: Ø®ÙˆØ±Ø´ÛŒØ¯ Ø®Ø§Ù…ÙˆØ´

if(sunOnOffBtn){
  // ÙˆØ¶Ø¹ÛŒØª Ø§ÙˆÙ„ÛŒÙ‡: Ø®ÙˆØ±Ø´ÛŒØ¯ Ø®Ø§Ù…ÙˆØ´ØŒ Ù†ÙˆØ± Ù…Ø­ÛŒØ·ÛŒ Ø²ÛŒØ§Ø¯ØŒ Ø±ÙˆÛŒ Ø¯Ú©Ù…Ù‡ Ø¨Ù†ÙˆÛŒØ³ "Ø±ÙˆØ´Ù†"
  sunlight.intensity = 0.0;
  ambient.intensity = 1.0;
  sunOnOffBtn.textContent = 'Ø±ÙˆØ´Ù†';

  sunOnOffBtn.addEventListener('click', ()=>{
    sunEnabled = !sunEnabled;
    if(sunEnabled){
      sunlight.intensity = 1.1;
      ambient.intensity = 0.25;
      sunOnOffBtn.textContent = 'Ø®Ø§Ù…ÙˆØ´';
    }else{
      sunlight.intensity = 0.0;
      ambient.intensity = 1.0;
      sunOnOffBtn.textContent = 'Ø±ÙˆØ´Ù†';
    }
  });
}


    const sunPanelEl=document.getElementById('sunPanel');
    const sunToggle=document.getElementById('sunToggle');
    const isMobile = window.matchMedia('(max-width: 768px)').matches;
    if (isMobile) sunPanelEl.classList.add('collapsed');
    sunToggle.addEventListener('click',()=>{
      sunPanelEl.classList.toggle('collapsed');
    });

    /* Ø¬Ù‡Øªâ€ŒÙ‡Ø§ÛŒ Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø³Ù‡â€ŒØ¨Ø¹Ø¯ÛŒ */
    const viewBar=document.getElementById('viewBar');
    function flyCamera(toPos,toTarget,dur=600){
      const fromPos=camera.position.clone();
      const fromTgt=orbit.target.clone();
      camTween={
        t0:performance.now(),
        dur,
        fromPos,
        toPos,
        fromTgt,
        toTarget
      };
      orbit.enabled=false;
    }
    function flyToDirection(dir){
      const tgt=orbit.target.clone();
      const dist=camera.position.distanceTo(tgt);
      const h=Math.max(camera.position.y,6);
      const off=new THREE.Vector3(
        dir==='east'?dist:dir==='west'?-dist:0,
        h,
        dir==='north'?dist:dir==='south'?-dist:0
      );
      flyCamera(new THREE.Vector3().addVectors(tgt,off), tgt, 600);
    }
    viewBar.addEventListener('click',e=>{
      const btn=e.target.closest('button[data-dir]');
      if(btn) flyToDirection(btn.dataset.dir);
    });

    /* ÙˆØ§ÛŒØ±ÙØ±ÛŒÙ… Ø³Ø±Ø§Ø³Ø±ÛŒ */
    const wireframeBtn = document.getElementById('wireframeBtn');
    let wireframeEnabled = false;

    function setGlobalWireframe(enabled){
      wireframeEnabled = enabled;

      scene.traverse(obj=>{
        if(obj.isMesh && obj.userData && obj.userData.isBlockPart){
          obj.material.wireframe = enabled;
          obj.material.needsUpdate = true;
        }
      });

      wireframeBtn.style.borderColor = enabled ? '#5eead4' : '#2b2f4a';
    }

    wireframeBtn.addEventListener('click', ()=>{
      setGlobalWireframe(!wireframeEnabled);
    });

    /* Apply color */
    const colorInput=document.getElementById('colorInput');
    const hexInput=document.getElementById('hexInput');
    const applyColorBtn=document.getElementById('applyColorBtn');
    colorInput.addEventListener('input',()=>{
      hexInput.value=colorInput.value;
    });
    hexInput.addEventListener('change',()=>{
      const v=(hexInput.value||'').trim();
      if(/^#([0-9a-fA-F]{6})$/.test(v))
        colorInput.value=v;
      else
        hexInput.value=colorInput.value;
    });
    function getBlockHexColor(block){
      let hex='#27e1c1';
      block.traverse(c=>{
        if(c.isMesh&&c.material&&c.material.color)
          hex='#'+c.material.color.getHexString();
      });
      return hex;
    }
    function setBlockColor(block, hex){
      const col=new THREE.Color(hex);
      block.traverse(c=>{
        if(c.isMesh&&c.material){
          c.material.color.copy(col);
          c.material.needsUpdate=true;
        }
      });
    }
    applyColorBtn.onclick=()=>{
      if(!selected){
        alert('Ø§Ø¨ØªØ¯Ø§ ÛŒÚ© Ø¨Ù„ÙˆÚ© Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.');
        return;
      }
      const id=selected.userData.id;
      const prev=getBlockHexColor(selected);
      const next=colorInput.value||'#27e1c1';
      if(prev.toLowerCase()===next.toLowerCase()) return;
      cmdRecolor(id,next);
      pushAction({type:'recolor', id, prevHex:prev, nextHex:next});
    };

    /* Ù…Ø¯ÛŒØ±ÛŒØª Ø·Ø¨Ù‚Ø§Øª Ù¾Ù„Ø§Ù† */
    function refreshPlanFloors(){
      const floorSet = new Set();

      blocks.forEach(b=>{
        const fi = getBlockFloorIndex(b);
        b.userData.floorIndex = fi;
        floorSet.add(fi);
      });

      const floors = Array.from(floorSet).sort((a,b)=>a-b);
      planFloorSelect.innerHTML = '';

      if(!floors.length){
        const opt = document.createElement('option');
        opt.value = '0';
        opt.textContent = '0';
        planFloorSelect.appendChild(opt);
        currentPlanFloor = 0;
        return;
      }

      if(!floors.includes(currentPlanFloor)){
        currentPlanFloor = floors[0];
      }

      floors.forEach(fi=>{
        const opt = document.createElement('option');
        opt.value = fi;
        opt.textContent = (fi + 1).toString(); // Ù†Ù…Ø§ÛŒØ´ 1ØŒ2ØŒ3...
        if(fi === currentPlanFloor) opt.selected = true;
        planFloorSelect.appendChild(opt);
      });
    }

    planFloorSelect.addEventListener('change', ()=>{
      currentPlanFloor = parseInt(planFloorSelect.value, 10) || 0;
    });

    /* Ù…Ø®ÙÛŒâ€ŒÚ©Ø±Ø¯Ù† Ø³Ù‚Ù/Ú©Ù Ùˆ ÙÛŒÙ„ØªØ± Ø·Ø¨Ù‚Ø§Øª ÙÙ‚Ø· Ø¯Ø± Ù¾Ù„Ø§Ù† */
    function setPlanHiddenSurfaces(isPlan){
      if (!isPlan){
        // Ø¯Ø± Ù†Ù…Ø§ÛŒ Ø§ØµÙ„ÛŒ: Ù‡Ù…Ù‡ Ú†ÛŒØ² Ø¯ÛŒØ¯Ù‡ Ø´ÙˆØ¯
        scene.traverse(obj=>{
          if(obj.userData && obj.userData.hideInPlan){
            obj.visible = true;
          }
        });
        blocks.forEach(b => { b.visible = true; });
        return;
      }

      // Ø¯Ø± Ù†Ù…Ø§ÛŒ Ù¾Ù„Ø§Ù†:
      scene.traverse(obj=>{
        if(obj.userData && obj.userData.hideInPlan){
          obj.visible = false;
        }
      });

      blocks.forEach(b=>{
        const fi = (typeof b.userData.floorIndex === 'number')
          ? b.userData.floorIndex
          : getBlockFloorIndex(b);
        b.userData.floorIndex = fi;
        b.visible = (fi === currentPlanFloor);
      });
    }

    /* Ú©Ù†ØªØ±Ù„ Ù¾Ù„Ø§Ù†: Ø³ÙˆÛŒÛŒÚ† + Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ Ø²ÙˆÙ… */
    const planToggleBtn = document.getElementById('planToggleBtn');
    const planZoomInBtn = document.getElementById('planZoomIn');
    const planZoomOutBtn = document.getElementById('planZoomOut');

    planToggleBtn.addEventListener('click', ()=>{
      showPlanFull = !showPlanFull;
      planToggleBtn.textContent = showPlanFull ? 'ğŸ‘ Ø³Ù‡â€ŒØ¨Ø¹Ø¯ÛŒ' : 'ğŸ‘ Ù¾Ù„Ø§Ù† Ú©ÙˆÚ†Ú©';
      if (showPlanFull){
        tctrl.detach();
        updateCoords(null);
      }else if(selected){
        selectObject(selected, false);
      }
    });

    planZoomInBtn.addEventListener('click', ()=>{
      applyPlanZoom(planZoom * 1.25);
    });

    planZoomOutBtn.addEventListener('click', ()=>{
      applyPlanZoom(planZoom / 1.25);
    });

    /* ØªØ´Ø®ÛŒØµ Ø§ÛŒÙ†Ú©Ù‡ Ù…ÙˆØ³ Ø±ÙˆÛŒ Ù¾Ù„Ø§Ù† Ú©ÙˆÚ†Ú© Ø§Ø³Øª ÛŒØ§ Ù†Ù‡ */
    function isPointerInMiniPlan(e){
      const rect = renderer.domElement.getBoundingClientRect();
      const w = rect.width;
      const h = rect.height;

      const size   = Math.min(w,h) * PLAN_REL_SIZE;
      const margin = PLAN_MARGIN;

      const x = e.clientX - rect.left;
      const yTop = e.clientY - rect.top;
      const yBottom = h - yTop; // Ú†ÙˆÙ† viewport Ù¾Ù„Ø§Ù† Ø§Ø² Ù¾Ø§ÛŒÛŒÙ† Ø´Ù…Ø±Ø¯Ù‡ Ø´Ø¯Ù‡

      return (
        x >= margin && x <= margin + size &&
        yBottom >= margin && yBottom <= margin + size
      );
    }

    /* Ø²ÙˆÙ… Ù¾Ù„Ø§Ù† Ø¨Ø§ ÙˆÛŒÙ„ Ù…ÙˆØ³ */
    renderer.domElement.addEventListener('wheel',(e)=>{
      if (showPlanFull || isPointerInMiniPlan(e)){
        e.preventDefault();
        const scale = Math.exp(-e.deltaY * 0.001);
        applyPlanZoom(planZoom * scale);
      }
    }, { passive:false });

    /* Ø±Ù†Ø¯Ø± Ø¯Ùˆ Ù†Ù…Ø§ (Ø§ØµÙ„ÛŒ + Ù¾Ù„Ø§Ù†) Ø¨Ø§ Ø®Ø§Ù…ÙˆØ´ Ú©Ø±Ø¯Ù† Ø³Ø§ÛŒÙ‡ Ø¯Ø± Ù¾Ù„Ø§Ù† */
    function renderViews(){
      const w = window.innerWidth;
      const h = window.innerHeight;

      // Ø§Ú¯Ø± Ù¾Ù„Ø§Ù† ØªÙ…Ø§Ù…â€ŒØµÙØ­Ù‡ Ø§Ø³Øª: ÙÙ‚Ø· Ù¾Ù„Ø§Ù† Ø¨Ø¯ÙˆÙ† Ø³Ø§ÛŒÙ‡
      if (showPlanFull){
        setPlanHiddenSurfaces(true);

        const prevShadow = renderer.shadowMap.enabled;
        renderer.shadowMap.enabled = false;       // âŒ Ø³Ø§ÛŒÙ‡ Ø®Ø§Ù…ÙˆØ´ ÙÙ‚Ø· Ø¨Ø±Ø§ÛŒ Ù¾Ù„Ø§Ù†

        renderer.setViewport(0,0,w,h);
        renderer.setScissor(0,0,w,h);
        renderer.setScissorTest(true);
        renderer.render(scene, planCamera);
        renderer.setScissorTest(false);

        renderer.shadowMap.enabled = prevShadow;  // âœ… Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯Ù† ØªÙ†Ø¸ÛŒÙ… Ù‚Ø¨Ù„ÛŒ
        setPlanHiddenSurfaces(false);
        return;
      }

      // Û±) Ù†Ù…Ø§ÛŒ Ø§ØµÙ„ÛŒ Ø¨Ø§ Ø³Ø§ÛŒÙ‡
      setPlanHiddenSurfaces(false);
      renderer.shadowMap.enabled = true;          // Ù…Ø·Ù…Ø¦Ù† Ø´Ùˆ Ø³Ø§ÛŒÙ‡ Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒ Ø§ØµÙ„ÛŒ Ø±ÙˆØ´Ù† Ø§Ø³Øª
      renderer.setViewport(0,0,w,h);
      renderer.setScissor(0,0,w,h);
      renderer.setScissorTest(true);
      renderer.render(scene, camera);

      // Û²) Ù¾Ù„Ø§Ù† Ú©ÙˆÚ†Ú© Ú¯ÙˆØ´Ù‡ Ù¾Ø§ÛŒÛŒÙ†-Ú†Ù¾ØŒ Ø¨Ø¯ÙˆÙ† Ø³Ø§ÛŒÙ‡
      const size   = Math.min(w,h) * PLAN_REL_SIZE;
      const margin = PLAN_MARGIN;
      const vpX = margin;
      const vpY = margin;

      setPlanHiddenSurfaces(true);

      const prevShadow = renderer.shadowMap.enabled;
      renderer.shadowMap.enabled = false;         // âŒ Ø³Ø§ÛŒÙ‡ Ø®Ø§Ù…ÙˆØ´ ÙÙ‚Ø· Ø¨Ø±Ø§ÛŒ Ù¾Ù„Ø§Ù† Ú©ÙˆÚ†Ú©

      renderer.setViewport(vpX,vpY,size,size);
      renderer.setScissor(vpX,vpY,size,size);
      renderer.setScissorTest(true);
      renderer.render(scene, planCamera);
      renderer.setScissorTest(false);

      renderer.shadowMap.enabled = prevShadow;    // âœ… Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯Ù†
      setPlanHiddenSurfaces(false);
    }

    /* Resize + Loop */
    window.addEventListener('resize',()=>{
      const w = window.innerWidth;
      const h = window.innerHeight;

      camera.aspect = w/h;
      camera.updateProjectionMatrix();

      updatePlanCameraFrustum();

      renderer.setSize(w,h);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
    });

    function animate(){
      const now=performance.now();
      if(camTween){
        const k=Math.min(1,(now-camTween.t0)/camTween.dur);
        const s=easeInOutQuad(k);
        camera.position.lerpVectors(camTween.fromPos,camTween.toPos,s);
        orbit.target.lerpVectors(camTween.fromTgt,camTween.toTarget,s);
        if(k>=1){
          camTween=null;
          orbit.enabled=true;
        }
      }
      orbit.update();

      // Ø¯ÙˆØ±Ø¨ÛŒÙ† Ù¾Ù„Ø§Ù† Ù‡Ù…ÛŒØ´Ù‡ Ø¨Ø§Ù„Ø§ÛŒ target
      const tgt = orbit.target;
      planCamera.position.set(tgt.x,150,tgt.z);
      planCamera.lookAt(tgt.x,0,tgt.z);

      renderViews();
      requestAnimationFrame(animate);
    }

    refreshPlanFloors();
    animate();
    updateHistoryButtons();
  </script>
</body>
</html>

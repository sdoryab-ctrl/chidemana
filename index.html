<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Ú†ÛŒØ¯Ù…Ø§Ù†Ø§</title>
  <style>
    /* Ù¾Ø§ÛŒÙ‡ */
    html,body{
      margin:0;
      height:100%;
      overflow:hidden;
      background:#bcd2e8;
      color:#fff;
      font-family:sans-serif;
    }
    #canvas{width:100%;height:100%;display:block;}

    /* Ù†ÙˆØ§Ø± Ø§Ø¨Ø²Ø§Ø± Ø³Ù…Øª Ø±Ø§Ø³Øª (Ø¯Ø³Ú©ØªØ§Ù¾) - Ø¨Ø§Ø±ÛŒÚ©â€ŒØªØ± */
    #toolbar{
      position:absolute;
      right:.6rem;
      top:50%;
      transform:translateY(-50%);
      display:flex;
      flex-direction:column;
      gap:.5rem;
      width:150px;
      z-index:6;
    }
    .toolbtn{
      background:#5eead4;
      border:none;
      border-radius:999px;
      padding:.55rem .8rem;
      font-weight:700;
      color:#0b1020;
      box-shadow:0 8px 20px rgba(94,234,212,.2);
      cursor:pointer;
      font-size:.9rem;
    }
    #toggleListBtn{display:none;} /* ÙÙ‚Ø· Ø¯Ø± Ø¯Ø³Ú©ØªØ§Ù¾ Ù…Ø®ÙÛŒØŒ Ø¯Ø± Ù…ÙˆØ¨Ø§ÛŒÙ„ Ù†Ø´ÙˆÙ† Ù…ÛŒâ€ŒØ¯ÛŒÙ… */
    .panel{
      background:#141a30;
      border:1px solid #2b2f4a;
      border-radius:12px;
      padding:.5rem .55rem;
      box-shadow:0 8px 24px rgba(0,0,0,.12);
    }
    #blockList{
      width:100%;
      height:160px;
      background:#12162a;
      color:#e6edf3;
      border:1px solid #2b2f4a;
      border-radius:10px;
      padding:.25rem;
      outline:none;
      font-size:.9rem;
    }
    #renameRow{display:flex; gap:.35rem; margin-top:.4rem;}
    #renameInput{
      width:70px;
      border:1px solid #2b2f4a;
      border-radius:10px;
      background:#12162a;
      color:#e6edf3;
      padding:.35rem .5rem;
      outline:none;
      font-size:.9rem;
    }

    /* Ø­Ø§Ù„Øª Ø­Ø±Ú©Øª/Ú†Ø±Ø®Ø´ (Ø¨Ø§Ù„Ø§-Ø±Ø§Ø³Øª) */
    #modeToolbar{
      position:absolute;
      top:.55rem;
      right:.55rem;
      display:flex;
      gap:.35rem;
      z-index:7;
    }
    .modebtn{
      padding:.4rem .65rem;
      border-radius:10px;
      border:1px solid #2b2f4a;
      background:#171d33;
      color:#e6edf3;
      font-size:.9rem;
    }

    /* Ù†ÙˆØ§Ø± Ù…ØªØ±ÛŒØ§Ù„ â€“ Ø¨Ø§Ù„Ø§-Ø±Ø§Ø³Øª (Ø¨Ø§Ø±ÛŒÚ©â€ŒØªØ±) */
    #materialBar{
      position:absolute;
      top:3.2rem;
      right:.55rem;
      z-index:7;
      display:flex;
      flex-direction:column;
      gap:.35rem;
      background:#101628;
      border:1px solid #5eead4;
      border-radius:12px;
      padding:.4rem .5rem;
      box-shadow:0 10px 28px rgba(0,0,0,.22);
      width:150px;
      box-sizing:border-box;
    }
    #colorInput{
      -webkit-appearance:none;
      appearance:none;
      width:100%;
      height:30px;
      border:none;
      border-radius:8px;
      cursor:pointer;
    }
    #hexInput{
      width:100%;
      border:1px solid #2b2f4a;
      border-radius:8px;
      background:#12162a;
      color:#e6edf3;
      padding:.35rem .5rem;
      outline:none;
      font-family:monospace;
      font-size:.85rem;
      box-sizing:border-box;
    }
    #applyColorBtn{
      background:#5eead4;
      color:#0b1020;
      border:none;
      border-radius:999px;
      padding:.35rem .5rem;
      font-weight:700;
      cursor:pointer;
      box-shadow:0 8px 20px rgba(94,234,212,.22);
      font-size:.85rem;
      width:100%;
    }

    /* Ù†ÙˆØ§Ø± Ø§Ù†ØªØ®Ø§Ø¨ Ù†ÙˆØ¹ Ø¨Ù„ÙˆÚ© â€“ Ú©Ù…ÛŒ Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ± Ø§Ø² Ù…ØªØ±ÛŒØ§Ù„ */
    #blockTypeBar{
      position:absolute;
      right:.55rem;
      top:11.2rem;
      z-index:7;
      display:flex;
      align-items:center;
      gap:.45rem;
      background:#101628;
      border:1px solid #2b2f4a;
      border-radius:12px;
      padding:.35rem .5rem;
      box-shadow:0 10px 28px rgba(0,0,0,.18);
      font-size:.85rem;
      color:#e6edf3;
      width:150px;
      box-sizing:border-box;
    }

    /* Ø¢ÛŒÚ©ÙˆÙ†â€ŒÙ‡Ø§ÛŒ Ù†ÙˆØ¹ Ø¨Ù„ÙˆÚ© */
    #blockTypeIcons{
      display:flex;
      gap:.25rem;
    }
    .blockTypeIcon{
      width:32px;
      height:32px;
      padding:0;
      border-radius:8px;
      border:1px solid #2b2f4a;
      background:#12162a;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
    }
    .blockTypeIcon.active{
      border-color:#5eead4;
      box-shadow:0 0 0 1px rgba(94,234,212,.5);
    }
    .bt-box{
      width:18px;
      height:18px;
      box-sizing:border-box;
      border-radius:3px;
    }
    /* Ù…Ø¹Ù…ÙˆÙ„ÛŒ: Ú†Ù‡Ø§Ø± Ø¶Ù„Ø¹ Ú©Ø§Ù…Ù„ */
    .bt-full{
      border:2px solid #5eead4;
    }
    /* Ø¨Ø¯ÙˆÙ† Ú©Ù: Ø³Ù‡ Ø¶Ù„Ø¹ Ø¨Ø§Ù„Ø§ Ùˆ Ø·Ø±ÙÛŒÙ† */
    .bt-no-bottom{
      border-top:2px solid #5eead4;
      border-left:2px solid #5eead4;
      border-right:2px solid #5eead4;
    }
    /* Ø¨Ø¯ÙˆÙ† Ø³Ù‚Ù: Ø³Ù‡ Ø¶Ù„Ø¹ Ù¾Ø§ÛŒÛŒÙ† Ùˆ Ø·Ø±ÙÛŒÙ† */
    .bt-no-top{
      border-bottom:2px solid #5eead4;
      border-left:2px solid #5eead4;
      border-right:2px solid #5eead4;
    }

    /* Undo/Redo Ø¨Ø§Ù„Ø§-Ú†Ù¾ */
    #historyBar{
      position:absolute;
      top:.55rem;
      left:.55rem;
      display:flex;
      gap:.35rem;
      z-index:7;
    }
    .histbtn{
      padding:.4rem .65rem;
      border-radius:10px;
      border:1px solid #2b2f4a;
      background:#171d33;
      color:#e6edf3;
      cursor:pointer;
      box-shadow:0 6px 16px rgba(0,0,0,.12);
      font-size:.85rem;
    }
    .histbtn:disabled{opacity:.45; cursor:not-allowed;}

    /* Ù¾Ù†Ù„ Ú©Ù†ØªØ±Ù„ Ø®ÙˆØ±Ø´ÛŒØ¯ + Ø®Ø±ÙˆØ¬ÛŒ â€“ Ø³Ù…Øª Ú†Ù¾ */
    #sunPanel{
      position:absolute;
      left:.55rem;
      top:50%;
      transform:translateY(-50%);
      width:220px;
      display:flex;
      flex-direction:column;
      gap:.35rem;
      z-index:6;
    }
    .sun-card{
      background:#141a30;
      border:1px solid #2b2f4a;
      border-radius:12px;
      overflow:hidden;
      box-shadow:0 8px 24px rgba(0,0,0,.12);
    }
    .sun-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:.6rem;
      padding:.5rem .6rem;
      cursor:pointer;
      user-select:none;
    }
    .sun-title{font-weight:700; font-size:.9rem;}
    .sun-chevron{transition:transform .2s ease;}
    .sun-body{
      padding:.5rem .6rem;
      border-top:1px solid #2b2f4a;
    }
    .row{
      display:flex;
      align-items:center;
      gap:.5rem;
      margin-top:.3rem;
    }
    .row label{
      min-width:70px;
      color:#cbd5e1;
      font-size:.86rem;
    }
    .row input[type="range"]{flex:1;}
    .num{
      width:60px;
      border:1px solid #2b2f4a;
      border-radius:8px;
      background:#12162a;
      color:#e6edf3;
      padding:.3rem .45rem;
      outline:none;
      text-align:center;
      font-size:.85rem;
    }
    .presetbar{
      display:flex;
      gap:.35rem;
      margin-top:.35rem;
      flex-wrap:wrap;
    }
    .presetbar button{
      padding:.3rem .5rem;
      border-radius:8px;
      border:1px solid #2b2f4a;
      background:#171d33;
      color:#e6edf3;
      cursor:pointer;
      font-size:.8rem;
    }
    .collapsed .sun-body{display:none;}
    .collapsed .sun-chevron{transform:rotate(180deg);}
    #sunOnOffBtn{
      padding:.3rem .6rem;
      border-radius:8px;
      border:1px solid #2b2f4a;
      background:#171d33;
      color:#e6edf3;
      cursor:pointer;
      font-size:.8rem;
    }

    /* Ø¬Ù‡Øªâ€ŒÙ‡Ø§ÛŒ Ø¯ÙˆØ±Ø¨ÛŒÙ† â€“ Ø¨Ø§Ù„Ø§ÛŒ ÙˆØ³Ø· (Ø¯Ø³Ú©ØªØ§Ù¾) */
    #viewBar{
      position:absolute;
      top:.55rem;
      left:50%;
      transform:translateX(-50%);
      display:flex;
      gap:.35rem;
      z-index:7;
    }
    .viewbtn{
      padding:.4rem .65rem;
      border-radius:10px;
      border:1px solid #2b2f4a;
      background:#171d33;
      color:#e6edf3;
      cursor:pointer;
      box-shadow:0 6px 16px rgba(0,0,0,.12);
      font-size:.85rem;
    }

    /* Ù†ÙˆØ§Ø± Ù…Ø®ØªØµØ§Øª Ø§Ù†ØªØ®Ø§Ø¨ â€“ Ø¯Ø§Ø®Ù„ Ù¾Ù†Ù„ Ù„ÛŒØ³Øª Ø¨Ù„ÙˆÚ©â€ŒÙ‡Ø§ */
    #coordsBar{
      margin-top:.35rem;
      background:rgba(11,16,32,.7);
      border:1px solid #2b2f4a;
      border-radius:999px;
      padding:.25rem .5rem;
      font-family:monospace;
      font-size:.8rem;
      box-shadow:0 4px 10px rgba(0,0,0,.1);
      opacity:.95;
      display:none;
    }

    /* Ù†ÙˆØ§Ø± Ú©Ù†ØªØ±Ù„ Ù¾Ù„Ø§Ù† (Ù¾Ø§ÛŒÛŒÙ†-Ú†Ù¾) */
    #planToggleBar{
      position:absolute;
      bottom:.9rem;
      left:.9rem;
      z-index:11;
      display:flex;
      gap:.25rem;
      align-items:center;
    }
    #planToggleBtn,
    #planZoomIn,
    #planZoomOut{
      padding:.28rem .55rem;
      border-radius:999px;
      border:1px solid #2b2f4a;
      background:#0b1020;
      color:#e6edf3;
      font-size:.8rem;
      opacity:.9;
      cursor:pointer;
    }
    #planZoomIn,#planZoomOut{
      width:26px;
      text-align:center;
      padding:.2rem 0;
    }

    /* Ù†ÙˆØ§Ø± Ø§Ù†ØªØ®Ø§Ø¨ Ø·Ø¨Ù‚Ù‡ Ø¨Ø±Ø§ÛŒ Ù¾Ù„Ø§Ù† */
    #planFloorBar{
      position:absolute;
      bottom:3.2rem;
      left:.9rem;
      z-index:11;
      display:flex;
      gap:.3rem;
      align-items:center;
      background:#0b1020;
      border:1px solid #2b2f4a;
      border-radius:999px;
      padding:.25rem .6rem;
      font-size:.8rem;
      opacity:.9;
    }
    #planFloorBar select{
      background:#12162a;
      color:#e6edf3;
      border:1px solid #2b2f4a;
      border-radius:8px;
      padding:.15rem .35rem;
      font-size:.8rem;
      outline:none;
    }
    #planFloorLabel{
      font-size:.8rem;
      color:#cbd5e1;
    }

    /* -------------------- Ø±ÛŒØ³Ù¾Ø§Ù†Ø³ÛŒÙˆ -------------------- */
    @media (max-width: 768px){
      :root{--scale-small:.9;}

      #modeToolbar,#historyBar,#materialBar,#blockTypeBar{transform-origin:top right;}
      #modeToolbar{transform:scale(var(--scale-small)); right:.5rem; top:.5rem;}
      #historyBar{transform:scale(var(--scale-small)); left:.5rem; top:.5rem;}
      #materialBar{
        transform:scale(var(--scale-small));
        right:.5rem;
        top:3rem;
        gap:.35rem;
        padding:.35rem .45rem;
        width:180px;
      }
      #blockTypeBar{
        right:.5rem;
        top:11.4rem;
        transform:scale(.9);
        width:180px;
      }
      #colorInput{width:100%;height:28px;border-radius:8px;}
      #hexInput{width:100%;padding:.3rem .45rem;font-size:.8rem;}
      #applyColorBtn{padding:.35rem .6rem;font-size:.8rem;}

      /* Ø¬Ù‡Øªâ€ŒÙ‡Ø§ÛŒ Ø¯ÙˆØ±Ø¨ÛŒÙ† â€“ Ù†Ø³Ø®Ù‡ Ù…ÙˆØ¨Ø§ÛŒÙ„: Ø³ØªÙˆÙ† Ø¯Ø± Ø³Ù…Øª Ø±Ø§Ø³Øª ØµÙØ­Ù‡ */
      #viewBar{
        right:.5rem;
        left:auto;
        top:8rem;
        transform:scale(var(--scale-small));
        flex-direction:column;
      }

      /* Ù†ÙˆØ§Ø± Ø§Ø¨Ø²Ø§Ø± Ù¾Ø§ÛŒÛŒÙ† Ù…ÙˆØ¨Ø§ÛŒÙ„ */
      #toolbar{
        position:fixed;
        left:calc(.5rem + env(safe-area-inset-left));
        right:calc(.5rem + env(safe-area-inset-right));
        bottom:calc(.5rem + env(safe-area-inset-bottom));
        top:auto;
        transform:none;
        width:auto;
        display:flex;
        flex-direction:row;
        align-items:stretch;
        gap:.45rem;
        z-index:10;
        backdrop-filter: blur(4px);
      }
      .toolbtn{padding:.45rem .6rem; font-size:.8rem; white-space:nowrap;}
      .panel{flex:1; padding:.4rem .45rem; border-radius:10px;}
      #blockList{height:84px; padding:.2rem; font-size:.8rem;}

      /* Ø¯Ú©Ù…Ù‡ Ù„ÛŒØ³Øª ÙÙ‚Ø· Ø¯Ø± Ù…ÙˆØ¨Ø§ÛŒÙ„ */
      #toggleListBtn{display:inline-block;}
      #blockPanel{display:none;}

      /* Ù¾Ù†Ù„ Ø®ÙˆØ±Ø´ÛŒØ¯ + Ø®Ø±ÙˆØ¬ÛŒ: Ø¨Ø§Ù„Ø§ÛŒ Ø³Ù…Øª Ú†Ù¾ */
      #sunPanel{
        width:180px;
        left:.5rem;
        top:4.5rem;
        bottom:auto;
        transform:none;
      }
      .row label{min-width:64px;}
      .num{width:56px;}

      .viewbtn,.modebtn,.histbtn{padding:.32rem .55rem; font-size:.8rem;}

      /* Ù¾Ù„Ø§Ù† Ùˆ Ú©Ù†ØªØ±Ù„â€ŒÙ‡Ø§ Ú©Ù…ÛŒ Ø¨Ø§Ù„Ø§ØªØ± Ú©Ù‡ Ø¨Ø§ ØªÙˆÙ„Ø¨Ø§Ø± ØªØ¯Ø§Ø®Ù„ Ù†Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ù†Ø¯ */
      #planToggleBar{
        bottom:4.5rem;
        left:.6rem;
      }
      #planFloorBar{
        bottom:7.8rem;
        left:.6rem;
      }
    }

    @media (max-width:420px){
      #materialBar{top:2.8rem;}
    }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <canvas id="canvas"></canvas>

  <!-- Ø­Ø§Ù„Øª Ø­Ø±Ú©Øª/Ú†Ø±Ø®Ø´ (Ø¨Ø§Ù„Ø§-Ø±Ø§Ø³Øª) -->
  <div id="modeToolbar">
    <button id="modeMove" class="modebtn">Ø­Ø±Ú©Øª (T)</button>
    <button id="modeRotate" class="modebtn">Ú†Ø±Ø®Ø´ (R)</button>
  </div>

  <!-- Ù†ÙˆØ§Ø± Ù…ØªØ±ÛŒØ§Ù„ (Ø¨Ø§Ù„Ø§-Ø±Ø§Ø³Øª) -->
  <div id="materialBar">
    <input id="colorInput" type="color" value="#27e1c1" />
    <input id="hexInput" placeholder="#RRGGBB" value="#27e1c1" />
    <button id="applyColorBtn">Ø§Ø¹Ù…Ø§Ù„</button>
  </div>

  <!-- Ù†ÙˆØ§Ø± Ø§Ù†ØªØ®Ø§Ø¨ Ù†ÙˆØ¹ Ø¨Ù„ÙˆÚ© Ø¨Ø§ Ø¢ÛŒÚ©ÙˆÙ† -->
  <div id="blockTypeBar">
    <span style="font-size:.8rem;">Ù†ÙˆØ¹ Ø¨Ù„ÙˆÚ©:</span>
    <div id="blockTypeIcons">
      <button class="blockTypeIcon active" data-type="full" title="Ù…Ø¹Ù…ÙˆÙ„ÛŒ">
        <div class="bt-box bt-full"></div>
      </button>
      <button class="blockTypeIcon" data-type="noBottom" title="Ø¨Ø¯ÙˆÙ† Ú©Ù">
        <div class="bt-box bt-no-bottom"></div>
      </button>
      <button class="blockTypeIcon" data-type="noTop" title="Ø¨Ø¯ÙˆÙ† Ø³Ù‚Ù">
        <div class="bt-box bt-no-top"></div>
      </button>
    </div>
  </div>

  <!-- Ù¾Ù†Ù„ Ú©Ù†ØªØ±Ù„ Ø®ÙˆØ±Ø´ÛŒØ¯ + Ø®Ø±ÙˆØ¬ÛŒ (Ø¬Ù…Ø¹â€ŒØ´ÙˆÙ†Ø¯Ù‡) -->
  <div id="sunPanel">
    <!-- Ú©Ø§Ø±Øª Ù†ÙˆØ± Ø®ÙˆØ±Ø´ÛŒØ¯ -->
    <div class="sun-card" id="sunCard">
      <div class="sun-header" id="sunToggle">
        <div class="sun-title">Ù†ÙˆØ± Ø®ÙˆØ±Ø´ÛŒØ¯</div>
        <div class="sun-chevron">â–¾</div>
      </div>
      <div class="sun-body" id="sunBody">
        <div class="row">
          <label>Ø§Ø±ØªÙØ§Ø¹ (Â°)</label>
          <input id="elevRange" type="range" min="0" max="90" step="1">
          <input id="elevNum" class="num" type="number" min="0" max="90" step="1">
        </div>
        <div class="row">
          <label>Ø¢Ø²ÛŒÙ…ÙˆØª (Â°)</label>
          <input id="azRange" type="range" min="0" max="360" step="1">
          <input id="azNum" class="num" type="number" min="0" max="360" step="1">
        </div>
        <div class="row">
          <label>Ø®ÙˆØ±Ø´ÛŒØ¯</label>
          <button id="sunOnOffBtn">Ø®Ø§Ù…ÙˆØ´</button>
        </div>
        <div class="presetbar">
          <button data-e="10" data-a="90">ØµØ¨Ø­</button>
          <button data-e="60" data-a="180">Ø¸Ù‡Ø±</button>
          <button data-e="15" data-a="260">Ø¹ØµØ±</button>
          <button data-e="3"  data-a="300">ØºØ±ÙˆØ¨</button>
        </div>
      </div>
    </div>

    <!-- Ú©Ø§Ø±Øª Ø®Ø±ÙˆØ¬ÛŒ ØªØµÙˆÛŒØ± Ø¯Ù‚ÛŒÙ‚Ø§ Ù‡Ù…â€ŒØ§Ø³ØªØ§ÛŒÙ„ Ù†ÙˆØ± Ø®ÙˆØ±Ø´ÛŒØ¯ -->
    <div class="sun-card" id="renderPanel">
      <div class="sun-header" id="renderToggle">
        <div class="sun-title">Ø®Ø±ÙˆØ¬ÛŒ ØªØµÙˆÛŒØ±</div>
        <div class="sun-chevron">â–¾</div>
      </div>
      <div class="sun-body" id="renderBody">
        <div class="row">
          <label>Ú©ÛŒÙÛŒØª</label>
          <select id="renderScale" class="num" style="width:100%;">
            <option value="1">1x (Ù…Ø¹Ù…ÙˆÙ„ÛŒ)</option>
            <option value="2" selected>2x (HD)</option>
            <option value="3">3x (Ultra)</option>
            <option value="4">4x (Max)</option>
          </select>
        </div>

        <div class="row">
          <label>ÙØ±Ù…Øª</label>
          <select id="renderFormat" class="num" style="width:100%;">
            <option value="png" selected>PNG</option>
            <option value="jpg">JPG</option>
          </select>
        </div>

        <div class="row">
          <label>Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡</label>
          <select id="renderBG" class="num" style="width:100%;">
            <option value="solid" selected>Ø«Ø§Ø¨Øª</option>
            <option value="transparent">Ø´ÙØ§Ù</option>
          </select>
        </div>

        <button id="renderDoBtn"
                style="width:100%; margin-top:.35rem;
                       padding:.45rem .5rem; border-radius:10px;
                       border:none; background:#5eead4; color:#0b1020;
                       font-weight:700; cursor:pointer; font-size:.85rem;">
          ğŸ“· Ø±Ù†Ø¯Ø± ØªØµÙˆÛŒØ±
        </button>
      </div>
    </div>
  </div>

  <!-- Ù†ÙˆØ§Ø± Ø§Ø¨Ø²Ø§Ø± (Ø¯Ø³Ú©ØªØ§Ù¾ Ø±Ø§Ø³Øª / Ù…ÙˆØ¨Ø§ÛŒÙ„ Ù¾Ø§ÛŒÛŒÙ†) -->
  <div id="toolbar">
    <button id="addBlockBtn" class="toolbtn">â• Ø§ÙØ²ÙˆØ¯Ù†</button>
    <button id="deleteBlockBtn" class="toolbtn" style="background:#f87171;color:#fff;">ğŸ—‘ï¸ Ø­Ø°Ù</button>
    <button id="toggleListBtn" class="toolbtn">ğŸ“‹ Ù„ÛŒØ³Øª</button>

    <div class="panel" id="blockPanel">
      <div style="font-weight:700; margin-bottom:.35rem;">Ù„ÛŒØ³Øª Ø¨Ù„ÙˆÚ©â€ŒÙ‡Ø§</div>
      <select id="blockList" size="8"></select>

      <!-- Ù…Ø®ØªØµØ§Øª Ø¨Ù„ÙˆÚ© Ø§Ù†ØªØ®Ø§Ø¨ÛŒ Ø²ÛŒØ± Ù„ÛŒØ³Øª -->
      <div id="coordsBar">X: 0.00 | Y: 0.00 | Z: 0.00</div>

      <div id="renameRow">
        <input id="renameInput" placeholder="Ù†Ø§Ù… Ø¬Ø¯ÛŒØ¯..." />
        <button id="renameBtn" class="toolbtn" style="padding:.35rem .6rem;">ØªØºÛŒÛŒØ± Ù†Ø§Ù…</button>
      </div>
    </div>
  </div>

  <!-- Undo/Redo -->
  <div id="historyBar">
    <button id="undoBtn" class="histbtn" title="Ctrl+Z">â†¶ Undo</button>
    <button id="redoBtn" class="histbtn" title="Ctrl+Y">â†· Redo</button>
  </div>

  <!-- Ø¬Ù‡Øªâ€ŒÙ‡Ø§ÛŒ Ø¯ÙˆØ±Ø¨ÛŒÙ† + ÙˆØ§ÛŒØ±ÙØ±ÛŒÙ… -->
  <div id="viewBar">
    <button class="viewbtn" data-dir="north">â¬† Ø´Ù…Ø§Ù„</button>
    <button class="viewbtn" data-dir="south">â¬‡ Ø¬Ù†ÙˆØ¨</button>
    <button class="viewbtn" data-dir="east">â¡ Ø´Ø±Ù‚</button>
    <button class="viewbtn" data-dir="west">â¬… ØºØ±Ø¨</button>
    <button id="wireframeBtn" class="viewbtn">ÙˆØ§ÛŒØ±ÙØ±ÛŒÙ…</button>
  </div>

  <!-- Ú©Ù†ØªØ±Ù„ Ù¾Ù„Ø§Ù† -->
  <div id="planToggleBar">
    <button id="planToggleBtn">ğŸ‘ Ù¾Ù„Ø§Ù† Ú©ÙˆÚ†Ú©</button>
    <button id="planZoomIn">+</button>
    <button id="planZoomOut">âˆ’</button>
  </div>

  <!-- Ø§Ù†ØªØ®Ø§Ø¨ Ø·Ø¨Ù‚Ù‡ Ø¨Ø±Ø§ÛŒ Ù¾Ù„Ø§Ù† -->
  <div id="planFloorBar">
    <span id="planFloorLabel">Ø·Ø¨Ù‚Ù‡:</span>
    <select id="planFloorSelect"></select>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { TransformControls } from 'three/addons/controls/TransformControls.js';
    import { Sky } from 'three/addons/objects/Sky.js';
    import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';

    /* Renderer */
    const renderer = new THREE.WebGLRenderer({
      canvas:document.getElementById('canvas'),
      antialias:true
    });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
    renderer.setSize(window.innerWidth,window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.VSMShadowMap;

    const scene = new THREE.Scene();

    /* ----- Ø¨Ø§ÙØª Ù‡Ø§Ø´ÙˆØ± Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒ Ù¾Ù„Ø§Ù† ----- */
    const hatchCanvas = document.createElement('canvas');
    hatchCanvas.width = hatchCanvas.height = 64;
    const hctx = hatchCanvas.getContext('2d');
    hctx.fillStyle = '#ffffff';
    hctx.fillRect(0, 0, 64, 64);
    hctx.strokeStyle = '#000000';
    hctx.lineWidth = 2;
    for (let i = -64; i < 64 * 2; i += 8) {
      hctx.beginPath();
      hctx.moveTo(i, 0);
      hctx.lineTo(i - 64, 64);
      hctx.stroke();
    }
    const hatchTex = new THREE.CanvasTexture(hatchCanvas);
    hatchTex.wrapS = hatchTex.wrapT = THREE.RepeatWrapping;
    hatchTex.repeat.set(2, 2);

    /* Sky + Sun */
    const sky = new Sky();
    sky.scale.setScalar(10000);
    scene.add(sky);
    const sunVec = new THREE.Vector3();
    let elevDeg = 80, azimDeg = 45;

    const sunlight = new THREE.DirectionalLight(0xffffff, 1.1);
    sunlight.castShadow = true;
    sunlight.shadow.mapSize.set(4096, 4096);
    sunlight.shadow.radius = 4;

    const SHADOW_EXTENT = 80;
    Object.assign(sunlight.shadow.camera, {
      left:   -SHADOW_EXTENT,
      right:   SHADOW_EXTENT,
      top:     SHADOW_EXTENT,
      bottom: -SHADOW_EXTENT,
      near:  1,
      far:  400
    });
    sunlight.shadow.bias       = -0.00005;
    sunlight.shadow.normalBias =  0.0025;

    scene.add(sunlight, sunlight.target);

    function setSunAngles(elev, azim){
      elevDeg = THREE.MathUtils.clamp(elev, 0, 90);
      azimDeg = ((azim%360)+360)%360;
      const phi = THREE.MathUtils.degToRad(90 - elevDeg);
      const theta = THREE.MathUtils.degToRad(azimDeg);
      sunVec.setFromSphericalCoords(1, phi, theta);
      const u = sky.material.uniforms;
      u.turbidity.value = 10;
      u.rayleigh.value = 2;
      u.mieCoefficient.value = 0.005;
      u.mieDirectionalG.value = 0.8;
      u.sunPosition.value.copy(sunVec);
      sunlight.position.copy(sunVec).multiplyScalar(120);
      sunlight.target.position.set(0,0,0);
      sunlight.target.updateMatrixWorld(true);
    }
    setSunAngles(elevDeg, azimDeg);

    const ambient = new THREE.AmbientLight(0xffffff, 0.35);
    scene.add(ambient);
    sunlight.intensity = 0.9;

    /* Camera + controls Ø§ØµÙ„ÛŒ */
    const camera = new THREE.PerspectiveCamera(55,window.innerWidth/window.innerHeight,.1,2000);
    camera.position.set(10,10,10);
    const orbit = new OrbitControls(camera,renderer.domElement);
    orbit.enableDamping = true;
    orbit.target.set(0,0,0);

    /* Ø¯ÙˆØ±Ø¨ÛŒÙ† Ù¾Ù„Ø§Ù† Ø§Ø² Ø¨Ø§Ù„Ø§ (Orthographic) + Ø²ÙˆÙ… */
    const FRUSTUM_SIZE = 150;
    let PLAN_REL_SIZE = 0.23;
    let PLAN_MARGIN   = 12;

    if (window.matchMedia('(max-width: 768px)').matches){
      PLAN_REL_SIZE = 0.18;
      PLAN_MARGIN   = 90;
    }

    let planZoom = 3;
    const PLAN_ZOOM_MIN = 0.01;
    const PLAN_ZOOM_MAX = 1000;

    const planCamera = new THREE.OrthographicCamera(-1,1,1,-1,0.1,1000);
    planCamera.position.set(0,150,0);
    planCamera.up.set(0,0,-1);
    planCamera.lookAt(0,0,0);

    const planControls = new OrbitControls(planCamera, renderer.domElement);
    planControls.enableDamping = true;
    planControls.enablePan = true;
    planControls.enableRotate = true;
    planControls.enableZoom = false; // Ø²ÙˆÙ… Ù¾Ù„Ø§Ù† Ø¨Ø§ planZoom Ø§Ù†Ø¬Ø§Ù… Ù…ÛŒâ€ŒØ´ÙˆØ¯
    planControls.minPolarAngle = 0;
    planControls.maxPolarAngle = Math.PI / 2;
    planControls.target.set(0,0,0);
    planControls.enabled = false;

    function updatePlanCameraFrustum(){
      const aspect = window.innerWidth / window.innerHeight;
      const size = FRUSTUM_SIZE / planZoom;
      planCamera.left   = -size * aspect / 2;
      planCamera.right  =  size * aspect / 2;
      planCamera.top    =  size / 2;
      planCamera.bottom = -size / 2;
      planCamera.updateProjectionMatrix();
    }
    function applyPlanZoom(newZoom){
      planZoom = THREE.MathUtils.clamp(newZoom, PLAN_ZOOM_MIN, PLAN_ZOOM_MAX);
      updatePlanCameraFrustum();
    }
    updatePlanCameraFrustum();

    /* Grid + ground */
    const grid = new THREE.GridHelper(300, 250, 0x77ffd0, 0x283047);
    grid.material.transparent=true;
    grid.material.opacity=.35;
    scene.add(grid);
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(300,300),
      new THREE.MeshStandardMaterial({
        color:0xd0e0f0,
        roughness:1,
        metalness:0
      })
    );
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    /* Block dims + chamfer + Ù†ÙˆØ¹ Ø¨Ù„ÙˆÚ© + Ú¯Ø±ÛŒØ¯ */
    const OUT_L = 5.98,
          OUT_W = 1.20,
          OUT_H = 3.09,
          WALL  = 0.225;

    const GRID_SIZE     = 1.20;
    const GRID_OFFSET_X = GRID_SIZE/2;
    const GRID_OFFSET_Z = GRID_SIZE/2;

    const GRID_Y_SIZE = OUT_H;
    const GRID_Y_BASE = OUT_H / 2;

    const CHAMFER = 0.02;
    const CHAMFER_SEGMENTS = 2;

    let BLOCK_TYPE = 'full';
    let showPlanFull = false;
    let currentPlanFloor = 0;

    /* Ø§Ù†ØªØ®Ø§Ø¨ Ù†ÙˆØ¹ Ø¨Ù„ÙˆÚ© Ø¨Ø§ Ø¢ÛŒÚ©ÙˆÙ†â€ŒÙ‡Ø§ */
    const blockTypeIcons = document.querySelectorAll('.blockTypeIcon');
    blockTypeIcons.forEach(btn=>{
      btn.addEventListener('click', ()=>{
        BLOCK_TYPE = btn.dataset.type;
        blockTypeIcons.forEach(b=>b.classList.toggle('active', b === btn));
      });
    });

    /* Ø³Ø§Ø²Ù†Ø¯Ù‡â€ŒÙ‡Ø§ */

    function createHollowBlockFull(){
      const g = new THREE.Group();
      const m = new THREE.MeshStandardMaterial({
        color: 0x27e1c1,
        metalness: 0.1,
        roughness: 0.4
      });

      const geoSide = new RoundedBoxGeometry(
        WALL,
        OUT_H,
        OUT_W,
        CHAMFER_SEGMENTS,
        CHAMFER
      );
      const lw = new THREE.Mesh(geoSide, m);
      lw.position.set(-(OUT_L/2 - WALL/2), 0, 0);
      lw.userData.isBlockPart = true;
      lw.userData.normalMaterial = lw.material;

      const rw = lw.clone();
      rw.position.x *= -1;
      rw.userData.isBlockPart = true;
      rw.userData.normalMaterial = rw.material;

      const geoTopBottom = new RoundedBoxGeometry(
        OUT_L,
        WALL,
        OUT_W,
        CHAMFER_SEGMENTS,
        CHAMFER
      );

      // Ø³Ù‚Ù
      const t = new THREE.Mesh(geoTopBottom, m);
      t.position.y = (OUT_H/2 - WALL/2);
      t.userData.hideInPlan  = true; // Ø³Ù‚Ù Ø¯Ø± Ù¾Ù„Ø§Ù† Ù…Ø®ÙÛŒ
      t.userData.isBlockPart = true;
      t.userData.normalMaterial = t.material;

      // Ú©Ù
      const b = new THREE.Mesh(geoTopBottom, m);
      b.position.y = -(OUT_H/2 - WALL/2);
      b.userData.hideInPlan  = false; // Ú©Ù Ø¯Ø± Ù¾Ù„Ø§Ù† Ø¯ÛŒØ¯Ù‡ Ø´ÙˆØ¯
      b.userData.isBlockPart = true;
      b.userData.normalMaterial = b.material;

      [lw, rw, t, b].forEach(w=>{
        w.castShadow = true;
        w.receiveShadow = true;
        g.add(w);
      });

      return g;
    }

    function createHollowBlockNoBottom(){
      const g = new THREE.Group();
      const m = new THREE.MeshStandardMaterial({
        color: 0x27e1c1,
        metalness: 0.1,
        roughness: 0.4
      });

      const geoSide = new RoundedBoxGeometry(
        WALL,
        OUT_H,
        OUT_W,
        CHAMFER_SEGMENTS,
        CHAMFER
      );
      const lw = new THREE.Mesh(geoSide, m);
      lw.position.set(-(OUT_L/2 - WALL/2), 0, 0);
      lw.userData.isBlockPart = true;
      lw.userData.normalMaterial = lw.material;

      const rw = lw.clone();
      rw.position.x *= -1;
      rw.userData.isBlockPart = true;
      rw.userData.normalMaterial = rw.material;

      const geoTop = new RoundedBoxGeometry(
        OUT_L,
        WALL,
        OUT_W,
        CHAMFER_SEGMENTS,
        CHAMFER
      );
      const t = new THREE.Mesh(geoTop, m);
      t.position.y = (OUT_H/2 - WALL/2);
      t.userData.hideInPlan  = true;
      t.userData.isBlockPart = true;
      t.userData.normalMaterial = t.material;

      [lw, rw, t].forEach(w=>{
        w.castShadow = true;
        w.receiveShadow = true;
        g.add(w);
      });

      return g;
    }

    // Ù†ÙˆØ¹ Ø¬Ø¯ÛŒØ¯: Ø¨Ø¯ÙˆÙ† Ø³Ù‚Ù (Ø¯ÛŒÙˆØ§Ø±Ù‡Ø§ + Ú©Ù)
    function createHollowBlockNoTop(){
      const g = new THREE.Group();
      const m = new THREE.MeshStandardMaterial({
        color: 0x27e1c1,
        metalness: 0.1,
        roughness: 0.4
      });

      const geoSide = new RoundedBoxGeometry(
        WALL,
        OUT_H,
        OUT_W,
        CHAMFER_SEGMENTS,
        CHAMFER
      );
      const lw = new THREE.Mesh(geoSide, m);
      lw.position.set(-(OUT_L/2 - WALL/2), 0, 0);
      lw.userData.isBlockPart = true;
      lw.userData.normalMaterial = lw.material;

      const rw = lw.clone();
      rw.position.x *= -1;
      rw.userData.isBlockPart = true;
      rw.userData.normalMaterial = rw.material;

      const geoBottom = new RoundedBoxGeometry(
        OUT_L,
        WALL,
        OUT_W,
        CHAMFER_SEGMENTS,
        CHAMFER
      );
      const b = new THREE.Mesh(geoBottom, m);
      b.position.y = -(OUT_H/2 - WALL/2);
      b.userData.hideInPlan  = false; // Ú©Ù Ø¯Ø± Ù¾Ù„Ø§Ù† Ø¯ÛŒØ¯Ù‡ Ø´ÙˆØ¯
      b.userData.isBlockPart = true;
      b.userData.normalMaterial = b.material;

      [lw, rw, b].forEach(w=>{
        w.castShadow = true;
        w.receiveShadow = true;
        g.add(w);
      });

      return g;
    }

    function createHollowBlock(){
      if (BLOCK_TYPE === 'noBottom') return createHollowBlockNoBottom();
      if (BLOCK_TYPE === 'noTop')    return createHollowBlockNoTop();
      return createHollowBlockFull();
    }

    /* State */
    const blocks=[];
    const blockMap=new Map();
    let blockCounter=0, nextId=1;
    const EPS=1e-6, ALLOW_OVERLAP=0.02;

    const planFloorSelect = document.getElementById('planFloorSelect');

    /* Helpers */
    const getWorldBox=o=>new THREE.Box3().setFromObject(o);

    function getBlockFloorIndexFromY(y){
      return Math.round((y - GRID_Y_BASE) / GRID_Y_SIZE);
    }
    function getBlockFloorIndex(block){
      return getBlockFloorIndexFromY(block.position.y);
    }

    function resolveCollisions(o, ignoreSet=null){
      const maxIter = 6;
      let moved = false;

      for(let iter = 0; iter < maxIter; iter++){
        let fixedAny = false;

        const a = getWorldBox(o);
        const aCenter = a.getCenter(new THREE.Vector3());

        for(const other of blocks){
          if(other === o) continue;
          if(ignoreSet && ignoreSet.has(other)) continue;

          const b = getWorldBox(other);
          if(!a.intersectsBox(b)) continue;

          const overlapX = Math.min(a.max.x - b.min.x, b.max.x - a.min.x);
          const overlapY = Math.min(a.max.y - b.min.y, b.max.y - a.min.y);
          const overlapZ = Math.min(a.max.z - b.min.z, b.max.z - a.min.z);
          const minOverlap = Math.min(overlapX, overlapY, overlapZ);

          if(minOverlap <= ALLOW_OVERLAP + EPS) continue;

          let axis = 'x';
          if(minOverlap === overlapY) axis = 'y';
          else if(minOverlap === overlapZ) axis = 'z';

          const bCenter = b.getCenter(new THREE.Vector3());
          const delta = new THREE.Vector3();
          const extra = minOverlap - ALLOW_OVERLAP;

          if(axis === 'x'){
            const dir = (aCenter.x >= bCenter.x) ? 1 : -1;
            delta.x = dir * extra;
          }else if(axis === 'y'){
            const dir = (aCenter.y >= bCenter.y) ? 1 : -1;
            delta.y = dir * extra;
          }else{
            const dir = (aCenter.z >= bCenter.z) ? 1 : -1;
            delta.z = dir * extra;
          }

          o.position.add(delta);
          fixedAny = true;
          moved = true;
        }

        if(!fixedAny) break;
      }

      clampGround(o);
      return moved;
    }

    function clampGround(o){
      const box=getWorldBox(o);
      if(box.min.y<0){
        o.position.y+=(-box.min.y+EPS);
      }
      if(o.position.y<OUT_H/2){
        o.position.y=OUT_H/2;
      }
    }

    function savePrevTransform(o){
      o.userData.prevPos=o.position.clone();
      o.userData.prevQuat=o.quaternion.clone();
    }

    const SNAP_TOL=0.15;
    const overlaps1D=(a1,a2,b1,b2)=>a1<=b2 && a2>=b1;

    function snapToNeighbors(o){
      if(!o) return false;
      const a=getWorldBox(o);
      const best={axis:null,dist:Infinity,delta:0};

      for(const other of blocks){
        if(other===o) continue;
        const b=getWorldBox(other);

        if(overlaps1D(a.min.y,a.max.y,b.min.y,b.max.y) &&
           overlaps1D(a.min.z,a.max.z,b.min.z,b.max.z)){
          const d1=Math.abs(a.min.x-b.max.x);
          if(d1<SNAP_TOL&&d1<best.dist){
            best.axis='x'; best.dist=d1; best.delta=b.max.x-a.min.x;
          }
          const d2=Math.abs(a.max.x-b.min.x);
          if(d2<SNAP_TOL&&d2<best.dist){
            best.axis='x'; best.dist=d2; best.delta=b.min.x-a.max.x;
          }
        }

        if(overlaps1D(a.min.y,a.max.y,b.min.y,b.max.y) &&
           overlaps1D(a.min.x,a.max.x,b.min.x,b.max.x)){
          const d3=Math.abs(a.min.z-b.max.z);
          if(d3<SNAP_TOL&&d3<best.dist){
            best.axis='z'; best.dist=d3; best.delta=b.max.z-a.min.z;
          }
          const d4=Math.abs(a.max.z-b.min.z);
          if(d4<SNAP_TOL&&d4<best.dist){
            best.axis='z'; best.dist=d4; best.delta=b.min.z-a.max.z;
          }
        }

        if(overlaps1D(a.min.x,a.max.x,b.min.x,b.max.x) &&
           overlaps1D(a.min.z,a.max.z,b.min.z,b.max.z)){
          const d5=Math.abs(a.min.y-b.max.y);
          if(d5<SNAP_TOL&&d5<best.dist){
            best.axis='y'; best.dist=d5; best.delta=b.max.y-a.min.y;
          }
          const d6=Math.abs(a.max.y-b.min.y);
          if(d6<SNAP_TOL&&d6<best.dist){
            best.axis='y'; best.dist=d6; best.delta=b.min.y-a.max.y;
          }
        }
      }

      if(best.axis){
        if(best.axis==='x') o.position.x += best.delta;
        if(best.axis==='y') o.position.y = Math.max(o.position.y + best.delta, OUT_H/2 + EPS);
        if(best.axis==='z') o.position.z += best.delta;

        resolveCollisions(o);
        clampGround(o);
        savePrevTransform(o);
        return true;
      }
      return false;
    }

    /* Ø§Ø³Ù†Ù¾ Ø±ÙˆÛŒ Ú¯Ø±ÛŒØ¯ */
    function snapToGrid(o){
      if (!o) return;

      o.position.x =
        GRID_OFFSET_X +
        Math.round((o.position.x - GRID_OFFSET_X) / GRID_SIZE) * GRID_SIZE;

      o.position.z =
        GRID_OFFSET_Z +
        Math.round((o.position.z - GRID_OFFSET_Z) / GRID_SIZE) * GRID_SIZE;

      o.position.y =
        GRID_Y_BASE +
        Math.round((o.position.y - GRID_Y_BASE) / GRID_Y_SIZE) * GRID_Y_SIZE;
    }

    /* Ø§Ù†ØªØ®Ø§Ø¨ + ÙˆØ§ÛŒØ±ÙØ±ÛŒÙ… Ø§Ù†ØªØ®Ø§Ø¨ */
    let selected=null;
    const selectedBlocks = new Set();
    const multiPivot = new THREE.Object3D();
    scene.add(multiPivot);

    function addWireframe(target){
      target.traverse(c=>{
        if(c.isMesh && !c.getObjectByName('__wf__')){
          const egeo=new THREE.EdgesGeometry(c.geometry,1);
          const line=new THREE.LineSegments(
            egeo,
            new THREE.LineBasicMaterial({
              color:0xffcc00,
              transparent:true,
              opacity:1
            })
          );
          line.name='__wf__';
          c.add(line);
        }
      });
    }
    function removeWireframe(target){
      if(!target) return;
      target.traverse(c=>{
        const wf=c.getObjectByName('__wf__');
        if(wf){
          c.remove(wf);
          wf.geometry.dispose();
          wf.material.dispose();
        }
      });
    }

    const coordsBar=document.getElementById('coordsBar');
    function fmt(n){ return n.toFixed(2); }
    function updateCoords(o){
      if(!o){
        coordsBar.style.display='none';
        return;
      }
      const p=o.position;
      coordsBar.textContent=`X: ${fmt(p.x)} | Y: ${fmt(p.y)} | Z: ${fmt(p.z)}`;
      coordsBar.style.display='block';
    }

// Ø§Ù†ØªØ®Ø§Ø¨/Ø¹Ø¯Ù… Ø§Ù†ØªØ®Ø§Ø¨ Ø¨Ù„ÙˆÚ© + Ú†Ù†Ø¯â€ŒØ§Ù†ØªØ®Ø§Ø¨ÛŒ
function selectObject(obj, additive = false){
  if (showPlanFull) return; // Ø¯Ø± Ù¾Ù„Ø§Ù† ØªÙ…Ø§Ù…â€ŒØµÙØ­Ù‡ØŒ Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ø¯Ø§Ø±ÛŒÙ…

  // Ø§Ú¯Ø± additive=falseØŒ Ø§ÙˆÙ„ Ù‡Ù…Ù‡â€ŒÚ†ÛŒ Ø±Ùˆ Ø®Ø§Ù„ÛŒ Ú©Ù†
  if (!additive){
    selectedBlocks.forEach(b => removeWireframe(b));
    selectedBlocks.clear();
  }

  // Ø§Ú¯Ø± Ø¨Ø§ Ctrl Ø±ÙˆÛŒ ÛŒÚ© Ø¨Ù„ÙˆÚ©Ù Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ù†ØªØ®Ø§Ø¨â€ŒØ´Ø¯Ù‡ Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒÙ… â†’ Ø§Ø² Ø§Ù†ØªØ®Ø§Ø¨ Ø®Ø§Ø±Ø¬Ø´ Ú©Ù†
  if (obj && additive && selectedBlocks.has(obj)){
    removeWireframe(obj);
    selectedBlocks.delete(obj);

    if (selectedBlocks.size === 0){
      selected = null;
      tctrl.detach();
      updateCoords(null);
    } else {
      selected = Array.from(selectedBlocks)[0];
      // Ø§Ú¯Ø± Ú†Ù†Ø¯ØªØ§ Ù…ÙˆÙ†Ø¯Ù†ØŒ Ø­ÙˆÙ„ pivot Ø¬Ø§Ø¨Ø¬Ø§ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
      if (selectedBlocks.size > 1){
        const center = new THREE.Vector3();
        selectedBlocks.forEach(b => center.add(b.position));
        center.multiplyScalar(1 / selectedBlocks.size);
        multiPivot.position.copy(center);
        tctrl.attach(multiPivot);
        updateCoords(multiPivot);
      } else {
        tctrl.attach(selected);
        updateCoords(selected);
      }
    }
  }
  else if (obj){
    // Ø§Ù†ØªØ®Ø§Ø¨ Ø¬Ø¯ÛŒØ¯
    selected = obj;
    selectedBlocks.add(obj);
    addWireframe(obj);

    if (selectedBlocks.size > 1){
      const center = new THREE.Vector3();
      selectedBlocks.forEach(b => center.add(b.position));
      center.multiplyScalar(1 / selectedBlocks.size);
      multiPivot.position.copy(center);
      tctrl.attach(multiPivot);
      updateCoords(multiPivot);
    } else {
      tctrl.attach(obj);
      updateCoords(obj);
    }
  }
  else{
    // Ú©Ù„ÛŒÚ© Ø±ÙˆÛŒ ÙØ¶Ø§ÛŒ Ø®Ø§Ù„ÛŒ Ø¨Ø¯ÙˆÙ† Ctrl â†’ Ø®Ø§Ù„ÛŒ Ú©Ø±Ø¯Ù† Ø§Ù†ØªØ®Ø§Ø¨
    selected = null;
    selectedBlocks.forEach(b => removeWireframe(b));
    selectedBlocks.clear();
    tctrl.detach();
    updateCoords(null);
  }

  // Ø³ÛŒÙ†Ú© UI (Ù„ÛŒØ³ØªØŒ Ù†Ø§Ù…ØŒ Ø±Ù†Ú¯)
  if (selected){
    renameInput.value = selected.name;

    const opt = [...blockList.options].find(o => +o.dataset.id === selected.userData.id);
    if (opt) blockList.value = opt.value;

    const hex = getBlockHexColor(selected);
    colorInput.value = hex;
    hexInput.value   = hex;
  } else {
    renameInput.value = '';
  }
}


    /* Transform controls */
    const tctrl=new TransformControls(camera,renderer.domElement);
    tctrl.setMode('translate');
    tctrl.setSpace('world');
    tctrl.setTranslationSnap(null);
    tctrl.setRotationSnap(THREE.MathUtils.degToRad(90));
    scene.add(tctrl);

    const btnMove=document.getElementById('modeMove');
    const btnRotate=document.getElementById('modeRotate');
    const updateUI=()=>{
      const isMove=tctrl.mode==='translate';
      btnMove.style.borderColor=isMove?'#5eead4':'#2b2f4a';
      btnRotate.style.borderColor=!isMove?'#5eead4':'#2b2f4a';
    };
    btnMove.onclick=()=>{tctrl.setMode('translate');updateUI();};
    btnRotate.onclick=()=>{
      tctrl.setMode('rotate');
      tctrl.setRotationSnap(THREE.MathUtils.degToRad(90));
      updateUI();
    };
    updateUI();
    tctrl.addEventListener('dragging-changed',e=>{
      if (!e.value) {
        orbit.enabled = true;
      } else {
        orbit.enabled = false;
      }
    });

    /* Ø§Ù†ÛŒÙ…ÛŒØ´Ù† Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§Ù‡Ø§ */
    let camTween=null;
    const easeInOutQuad=t=>t<.5?2*t*t:-1+(4-2*t)*t;

    tctrl.addEventListener('change', ()=>{
      if (!tctrl.dragging) return;
      if (showPlanFull) return;

      const o = tctrl.object;
      if (!o) return;

      const ignoreSet = (selectedBlocks.size > 1 ? selectedBlocks : null);

      if (tctrl.mode === 'translate') {

        if (!o.userData.lastPosDuringDrag) {
          o.userData.lastPosDuringDrag = o.position.clone();
          snapToGrid(o);
          o.userData.lastPosDuringDrag.copy(o.position);
        }

        snapToGrid(o);

        const delta = new THREE.Vector3().subVectors(
          o.position,
          o.userData.lastPosDuringDrag
        );
        o.userData.lastPosDuringDrag.copy(o.position);

        if (o === multiPivot) {
          if (delta.lengthSq() > 0 && selectedBlocks.size) {
            selectedBlocks.forEach(b=>{
              b.position.add(delta);
              resolveCollisions(b, ignoreSet);
              clampGround(b);
              snapToGrid(b);
            });
          }
        } else {
          resolveCollisions(o, ignoreSet);
          clampGround(o);
          snapToGrid(o);

          if (delta.lengthSq() > 0 && selectedBlocks.size > 1) {
            selectedBlocks.forEach(b=>{
              if (b === o) return;
              b.position.add(delta);
              resolveCollisions(b, ignoreSet);
              clampGround(b);
              snapToGrid(b);
            });
          }
        }

        updateCoords(o === multiPivot ? multiPivot : o);
      } else {
        resolveCollisions(o, ignoreSet);
        clampGround(o);
        updateCoords(o === multiPivot ? multiPivot : o);
      }
    });

    tctrl.addEventListener('mouseUp', ()=>{
      if (showPlanFull) return;
      const o = tctrl.object;
      if(!o) return;

      o.userData.lastPosDuringDrag = null;
      const ignoreSet = (selectedBlocks.size > 1 ? selectedBlocks : null);

      if(o === multiPivot){
        selectedBlocks.forEach(b=>{
          snapToNeighbors(b);
          resolveCollisions(b, ignoreSet);
          clampGround(b);
          snapToGrid(b);
          savePrevTransform(b);
        });
        updateCoords(multiPivot);
      }else{
        snapToNeighbors(o);
        resolveCollisions(o, ignoreSet);
        clampGround(o);
        snapToGrid(o);

        if(selectedBlocks.size > 1){
          selectedBlocks.forEach(b=>{
            if(b === o) return;
            snapToNeighbors(b);
            resolveCollisions(b, ignoreSet);
            clampGround(b);
            snapToGrid(b);
            savePrevTransform(b);
          });
        }

        updateCoords(o);
        savePrevTransform(o);
      }

      refreshPlanFloors();
    });

    /* ØªØ§Ø±ÛŒØ®Ú†Ù‡ */
    const undoBtn=document.getElementById('undoBtn');
    const redoBtn=document.getElementById('redoBtn');
    const history=[];
    const future=[];
    const pushAction=a=>{
      history.push(a);
      future.length=0;
      updateHistoryButtons();
    };
    const updateHistoryButtons=()=>{
      undoBtn.disabled=history.length===0;
      redoBtn.disabled=future.length===0;
    };
    const blockList=document.getElementById('blockList');
    const renameInput=document.getElementById('renameInput');
    const renameBtn=document.getElementById('renameBtn');

    const serializeBlock=b=>({
      id:b.userData.id,
      name:b.name,
      pos:b.position.clone(),
      quat:b.quaternion.clone(),
      colorHex:getBlockHexColor(b)
    });

    function performAddFromState(state, selectAfter=true){
      const b=createHollowBlock();
      b.name=state.name;
      b.userData.id=state.id;
      b.position.copy(state.pos);
      b.quaternion.copy(state.quat);
      setBlockColor(b, state.colorHex||'#27e1c1');
      scene.add(b);
      blocks.push(b);
      blockMap.set(b.userData.id,b);
      addBlockToList(b);
      if(selectAfter) selectObject(b);
      return b;
    }
    const cmdAddBlock=st=>performAddFromState(st,true);

    function cmdDeleteBlock(id){
      const b=findBlockById(id);
      if(!b) return;
      removeWireframe(b);
      scene.remove(b);
      const i=blocks.indexOf(b);
      if(i!==-1) blocks.splice(i,1);
      blockMap.delete(id);
      removeBlockFromList(b);
      if(selected===b) selectObject(null);
      refreshPlanFloors();
    }
    function cmdRename(id,newName){
      const b=findBlockById(id);
      if(!b) return;
      b.name=newName;
      updateBlockNameInList(id,newName);
      if(selected===b){
        renameInput.value=newName;
        blockList.value=newName;
      }
    }
    function cmdTransform(id,pose){
      const b=findBlockById(id);
      if(!b) return;
      b.position.copy(pose.pos);
      b.quaternion.copy(pose.quat);
      clampGround(b);
      updateCoords(b);
    }
    function cmdRecolor(id,colorHex){
      const b=findBlockById(id);
      if(!b) return;
      setBlockColor(b,colorHex);
      if(selected===b){
        colorInput.value=colorHex;
        hexInput.value=colorHex;
      }
    }

    function undo(){
      const a=history.pop();
      if(!a) return;
      future.push(a);
      updateHistoryButtons();
      switch(a.type){
        case'add':
          cmdDeleteBlock(a.state.id);
          break;
        case'delete':
          cmdAddBlock(a.state);
          break;
        case'rename':
          cmdRename(a.id,a.prevName);
          break;
        case'transform':
          cmdTransform(a.id,a.prev);
          if(selected&&selected.userData.id===a.id)
            selectObject(findBlockById(a.id));
          break;
        case'recolor':
          cmdRecolor(a.id,a.prevHex);
          break;
      }
      refreshPlanFloors();
    }
    function redo(){
      const a=future.pop();
      if(!a) return;
      history.push(a);
      updateHistoryButtons();
      switch(a.type){
        case'add':
          cmdAddBlock(a.state);
          break;
        case'delete':
          cmdDeleteBlock(a.state.id);
          break;
        case'rename':
          cmdRename(a.id,a.nextName);
          break;
        case'transform':
          cmdTransform(a.id,a.next);
          if(selected&&selected.userData.id===a.id)
            selectObject(findBlockById(a.id));
          break;
        case'recolor':
          cmdRecolor(a.id,a.nextHex);
          break;
      }
      refreshPlanFloors();
    }
    undoBtn.onclick=undo;
    redoBtn.onclick=redo;
    window.addEventListener('keydown',e=>{
      if((e.ctrlKey||e.metaKey)&&e.key.toLowerCase()==='z'){
        e.preventDefault();undo();
      }
      if((e.ctrlKey||e.metaKey)&&e.key.toLowerCase()==='y'){
        e.preventDefault();redo();
      }
    });

    /* Ù„ÛŒØ³Øª Ù†Ø§Ù…â€ŒÙ‡Ø§ */
    function addBlockToList(block){
      const opt=document.createElement('option');
      opt.value=block.name;
      opt.textContent=block.name;
      opt.dataset.id=block.userData.id;
      blockList.appendChild(opt);
    }
    function removeBlockFromList(block){
      [...blockList.options].forEach(o=>{
        if(+o.dataset.id===block.userData.id) o.remove();
      });
    }
    function updateBlockNameInList(id,newName){
      [...blockList.options].forEach(o=>{
        if(+o.dataset.id===id){
          o.value=newName;
          o.textContent=newName;
        }
      });
    }
    const findBlockById=id=>blockMap.get(id)||null;

    blockList.addEventListener('change',()=>{
      const opt=blockList.selectedOptions[0];
      if(!opt){
        selectObject(null);
        return;
      }
      const b=findBlockById(+opt.dataset.id);
      selectObject(b||null,false);
    });

    /* Ø§ÙØ²ÙˆØ¯Ù†/Ø­Ø°Ù/ØªØºÛŒÛŒØ± Ù†Ø§Ù… */
    document.getElementById('addBlockBtn').onclick=()=>{
      const b=createHollowBlock();
      b.userData.id=nextId++;
      b.name=`Ø¨Ù„ÙˆÚ© ${++blockCounter}`;
      if(blocks.length===0){
        b.position.set(2.99, 1.54, 0.60);
      }else{
        const last=blocks[blocks.length-1];
        const lb=getWorldBox(last);
        b.position.set(lb.max.x+(OUT_L/2), last.position.y, last.position.z);
      }
      setBlockColor(b, colorInput.value||'#27e1c1');
      scene.add(b);
      blocks.push(b);
      blockMap.set(b.userData.id,b);
      clampGround(b);
      snapToGrid(b);
      savePrevTransform(b);
      addBlockToList(b);
      selectObject(b);
      pushAction({type:'add', state:serializeBlock(b)});
      updateHistoryButtons();
      refreshPlanFloors();
    };

    document.getElementById('deleteBlockBtn').onclick=()=>{
      if(!selected){
        alert('Ø§Ø¨ØªØ¯Ø§ ÛŒÚ© Ø¨Ù„ÙˆÚ© Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.');
        return;
      }
      const st=serializeBlock(selected);
      cmdDeleteBlock(selected.userData.id);
      pushAction({type:'delete', state:st});
      refreshPlanFloors();
    };

    renameBtn.onclick=()=>{
      if(!selected){
        alert('Ø§Ø¨ØªØ¯Ø§ ÛŒÚ© Ø¨Ù„ÙˆÚ© Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.');
        return;
      }
      const id=selected.userData.id;
      const prev=selected.name;
      const next=(renameInput.value||'').trim();
      if(!next){
        alert('Ù†Ø§Ù… Ø¬Ø¯ÛŒØ¯ Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª.');
        return;
      }
      if(prev===next) return;
      cmdRename(id,next);
      pushAction({type:'rename', id, prevName:prev, nextName:next});
    };

    /* Ø¨Ø§Ø² Ùˆ Ø¨Ø³ØªÙ‡â€ŒÚ©Ø±Ø¯Ù† Ù„ÛŒØ³Øª Ø¨Ù„ÙˆÚ©â€ŒÙ‡Ø§ Ø¯Ø± Ù…ÙˆØ¨Ø§ÛŒÙ„ */
    const blockPanel = document.getElementById('blockPanel');
    const toggleListBtn = document.getElementById('toggleListBtn');
    if (toggleListBtn && blockPanel){
      const isMobileList = window.matchMedia('(max-width: 768px)').matches;
      if(isMobileList){
        blockPanel.style.display = 'none';
      }
      toggleListBtn.addEventListener('click', ()=>{
        const hidden = blockPanel.style.display === 'none';
        blockPanel.style.display = hidden ? 'block' : 'none';
      });
    }

    /* Picking */
    const raycaster=new THREE.Raycaster();
    const pointer=new THREE.Vector2();
    const setPointer=e=>{
      const r=renderer.domElement.getBoundingClientRect();
      pointer.set(
        (e.clientX-r.left)/r.width*2-1,
        -((e.clientY-r.top)/r.height*2-1)
      );
    };
    function pickBlock(){
      raycaster.setFromCamera(pointer,camera);
      const hits=raycaster.intersectObjects(blocks,true);
      if(!hits.length) return null;
      let o=hits[0].object;
      while(o && !blocks.includes(o)) o=o.parent;
      return o;
    }

    /* ØªØ´Ø®ÛŒØµ Ø§ÛŒÙ†Ú©Ù‡ Ù…ÙˆØ³ Ø±ÙˆÛŒ Ù¾Ù„Ø§Ù† Ú©ÙˆÚ†Ú© Ø§Ø³Øª ÛŒØ§ Ù†Ù‡ */
    function isPointerInMiniPlan(e){
      const rect = renderer.domElement.getBoundingClientRect();
      const w = rect.width;
      const h = rect.height;

      const size   = Math.min(w,h) * PLAN_REL_SIZE;
      const margin = PLAN_MARGIN;

      const x = e.clientX - rect.left;
      const yTop = e.clientY - rect.top;
      const yBottom = h - yTop;

      return (
        x >= margin && x <= margin + size &&
        yBottom >= margin && yBottom <= margin + size
      );
    }

    /* Ø§Ù†ØªØ®Ø§Ø¨ Ø¨Ø§ Ú©Ù„ÛŒÚ© (Ctrl Ø¨Ø±Ø§ÛŒ Ú†Ù†Ø¯Ø§Ù†ØªØ®Ø§Ø¨ÛŒ) */
    renderer.domElement.addEventListener('pointerdown',e=>{
      const inPlanRegion = showPlanFull || isPointerInMiniPlan(e);

      planControls.enabled = inPlanRegion;
      if (!tctrl.dragging) {
        orbit.enabled = !inPlanRegion;
      }

      if (inPlanRegion){
        return;
      }

      if (showPlanFull) return;

      setPointer(e);
      if(tctrl.axis||tctrl.dragging) return;

      const hit = pickBlock();
      const additive = e.ctrlKey || e.metaKey;

      if(hit){
        selectObject(hit, additive);
      }else if(!additive){
        selectObject(null);
      }
    });

    /* Ú©Ù†ØªØ±Ù„â€ŒÙ‡Ø§ÛŒ Ø®ÙˆØ±Ø´ÛŒØ¯ + Ø¨Ø§Ø²/Ø¨Ø³ØªÙ‡ Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§ */
    const elevRange=document.getElementById('elevRange');
    const elevNum=document.getElementById('elevNum');
    const azRange=document.getElementById('azRange');
    const azNum=document.getElementById('azNum');

    const syncSunInputs=()=>{
      elevRange.value=elevDeg;
      elevNum.value=elevDeg;
      azRange.value=azimDeg;
      azNum.value=azimDeg;
    };
    const onSunChange=()=>setSunAngles(+elevNum.value, +azNum.value);

    elevRange.addEventListener('input',()=>{
      elevNum.value=elevRange.value;
      onSunChange();
    });
    elevNum.addEventListener('change',()=>{
      elevRange.value=elevNum.value;
      onSunChange();
    });
    azRange.addEventListener('input',()=>{
      azNum.value=azRange.value;
      onSunChange();
    });
    azNum.addEventListener('change',()=>{
      azRange.value=azNum.value;
      onSunChange();
    });

    document.querySelectorAll('.presetbar button').forEach(btn=>{
      btn.addEventListener('click',()=>{
        setSunAngles(+btn.dataset.e, +btn.dataset.a);
        syncSunInputs();
      });
    });
    syncSunInputs();

    const sunOnOffBtn = document.getElementById('sunOnOffBtn');
    let sunEnabled = false;

    if(sunOnOffBtn){
      sunlight.intensity = 0.0;
      ambient.intensity = 1.0;
      sunOnOffBtn.textContent = 'Ø±ÙˆØ´Ù†';

      sunOnOffBtn.addEventListener('click', ()=>{
        sunEnabled = !sunEnabled;
        if(sunEnabled){
          sunlight.intensity = 1.1;
          ambient.intensity = 0.25;
          sunOnOffBtn.textContent = 'Ø®Ø§Ù…ÙˆØ´';
        }else{
          sunlight.intensity = 0.0;
          ambient.intensity = 1.0;
          sunOnOffBtn.textContent = 'Ø±ÙˆØ´Ù†';
        }
      });
    }

    // Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§ÛŒ Ø®ÙˆØ±Ø´ÛŒØ¯ Ùˆ Ø®Ø±ÙˆØ¬ÛŒ: Ø§Ø² Ø§ÙˆÙ„ Ø¨Ø³ØªÙ‡
    const sunCard   = document.getElementById('sunCard');
    const sunToggle = document.getElementById('sunToggle');
    const renderCard   = document.getElementById('renderPanel');
    const renderToggle = document.getElementById('renderToggle');

    sunCard.classList.add('collapsed');
    renderCard.classList.add('collapsed');

    sunToggle.addEventListener('click',()=>{
      sunCard.classList.toggle('collapsed');
    });
    renderToggle.addEventListener('click',()=>{
      renderCard.classList.toggle('collapsed');
    });

    /* Ø¬Ù‡Øªâ€ŒÙ‡Ø§ÛŒ Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø³Ù‡â€ŒØ¨Ø¹Ø¯ÛŒ */
    const viewBar=document.getElementById('viewBar');
    function flyCamera(toPos,toTarget,dur=600){
      const fromPos=camera.position.clone();
      const fromTgt=orbit.target.clone();
      camTween={
        t0:performance.now(),
        dur,
        fromPos,
        toPos,
        fromTgt,
        toTarget
      };
      orbit.enabled=false;
    }
    function flyToDirection(dir){
      const tgt=orbit.target.clone();
      const dist=camera.position.distanceTo(tgt);
      const h=Math.max(camera.position.y,6);
      const off=new THREE.Vector3(
        dir==='east'?dist:dir==='west'?-dist:0,
        h,
        dir==='north'?dist:dir==='south'?-dist:0
      );
      flyCamera(new THREE.Vector3().addVectors(tgt,off), tgt, 600);
    }
    viewBar.addEventListener('click',e=>{
      const btn=e.target.closest('button[data-dir]');
      if(btn) flyToDirection(btn.dataset.dir);
    });

    /* ÙˆØ§ÛŒØ±ÙØ±ÛŒÙ… Ø³Ø±Ø§Ø³Ø±ÛŒ */
    const wireframeBtn = document.getElementById('wireframeBtn');
    let wireframeEnabled = false;

    function setGlobalWireframe(enabled){
      wireframeEnabled = enabled;

      scene.traverse(obj=>{
        if(obj.isMesh && obj.userData && obj.userData.isBlockPart){
          obj.material.wireframe = enabled;
          obj.material.needsUpdate = true;
        }
      });

      wireframeBtn.style.borderColor = enabled ? '#5eead4' : '#2b2f4a';
    }

    wireframeBtn.addEventListener('click', ()=>{
      setGlobalWireframe(!wireframeEnabled);
    });

    /* Apply color */
    const colorInput=document.getElementById('colorInput');
    const hexInput=document.getElementById('hexInput');
    const applyColorBtn=document.getElementById('applyColorBtn');
    colorInput.addEventListener('input',()=>{
      hexInput.value=colorInput.value;
    });
    hexInput.addEventListener('change',()=>{
      const v=(hexInput.value||'').trim();
      if(/^#([0-9a-fA-F]{6})$/.test(v))
        colorInput.value=v;
      else
        hexInput.value=colorInput.value;
    });
    function getBlockHexColor(block){
      let hex='#27e1c1';
      block.traverse(c=>{
        if(c.isMesh&&c.material&&c.material.color)
          hex='#'+c.material.color.getHexString();
      });
      return hex;
    }
    function setBlockColor(block, hex){
      const col = new THREE.Color(hex);
      block.traverse(c=>{
        if(c.isMesh && c.material){
          if(!c.userData.normalMaterial){
            c.userData.normalMaterial = c.material;
          }
          c.userData.normalMaterial.color.copy(col);
          c.userData.normalMaterial.needsUpdate = true;

          if (c.userData.planMaterial){
            c.userData.planMaterial.color.copy(col);
            c.userData.planMaterial.needsUpdate = true;
          }

          if (!showPlanFull){
            c.material = c.userData.normalMaterial;
          }
        }
      });
    }

    applyColorBtn.onclick=()=>{
      if(!selected){
        alert('Ø§Ø¨ØªØ¯Ø§ ÛŒÚ© Ø¨Ù„ÙˆÚ© Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.');
        return;
      }
      const id=selected.userData.id;
      const prev=getBlockHexColor(selected);
      const next=colorInput.value||'#27e1c1';
      if(prev.toLowerCase()===next.toLowerCase()) return;
      cmdRecolor(id,next);
      pushAction({type:'recolor', id, prevHex:prev, nextHex:next});
    };

    /* Ù…Ø¯ÛŒØ±ÛŒØª Ø·Ø¨Ù‚Ø§Øª Ù¾Ù„Ø§Ù† */
    function refreshPlanFloors(){
      const floorSet = new Set();

      blocks.forEach(b=>{
        const fi = getBlockFloorIndex(b);
        b.userData.floorIndex = fi;
        floorSet.add(fi);
      });

      const floors = Array.from(floorSet).sort((a,b)=>a-b);
      planFloorSelect.innerHTML = '';

      if(!floors.length){
        const opt = document.createElement('option');
        opt.value = '0';
        opt.textContent = '0';
        planFloorSelect.appendChild(opt);
        currentPlanFloor = 0;
        return;
      }

      if(!floors.includes(currentPlanFloor)){
        currentPlanFloor = floors[0];
      }

      floors.forEach(fi=>{
        const opt = document.createElement('option');
        opt.value = fi;
        opt.textContent = (fi + 1).toString();
        if(fi === currentPlanFloor) opt.selected = true;
        planFloorSelect.appendChild(opt);
      });
    }

    planFloorSelect.addEventListener('change', ()=>{
      currentPlanFloor = parseInt(planFloorSelect.value, 10) || 0;
    });

    /* Ù…Ø®ÙÛŒâ€ŒÚ©Ø±Ø¯Ù† Ø³Ù‚Ù Ùˆ ÙÛŒÙ„ØªØ± Ø·Ø¨Ù‚Ø§Øª ÙÙ‚Ø· Ø¯Ø± Ù¾Ù„Ø§Ù† */
    function setPlanHiddenSurfaces(isPlan){
      if (!isPlan){
        scene.traverse(obj=>{
          if(obj.userData && obj.userData.hideInPlan){
            obj.visible = true;
          }
        });
        blocks.forEach(b => { b.visible = true; });
        return;
      }

      scene.traverse(obj=>{
        if(obj.userData && obj.userData.hideInPlan){
          obj.visible = false;
        }
      });

      blocks.forEach(b=>{
        const fi = (typeof b.userData.floorIndex === 'number')
          ? b.userData.floorIndex
          : getBlockFloorIndex(b);
        b.userData.floorIndex = fi;
        b.visible = (fi === currentPlanFloor);
      });
    }

    /* Ù…ØªØ±ÛŒØ§Ù„ Ù‡Ø§Ø´ÙˆØ± Ø¨Ø±Ø§ÛŒ Ù¾Ù„Ø§Ù† Ø±ÙˆØ´Ù†/Ø®Ø§Ù…ÙˆØ´ */
    function setPlanHatching(enable){
      scene.traverse(obj=>{
        if (obj.isMesh && obj.userData && obj.userData.isBlockPart){
          if (!obj.userData.normalMaterial){
            obj.userData.normalMaterial = obj.material;
          }

          if (enable){
            if (!obj.userData.planMaterial){
              const baseColor = obj.userData.normalMaterial.color.clone();
              obj.userData.planMaterial = new THREE.MeshBasicMaterial({
                color: baseColor,
                map: hatchTex,
                transparent: true,
                opacity: 0.7
              });
            } else {
              obj.userData.planMaterial.color.copy(obj.userData.normalMaterial.color);
            }
            obj.material = obj.userData.planMaterial;
          } else {
            if (obj.userData.normalMaterial){
              obj.material = obj.userData.normalMaterial;
            }
          }
        }
      });
    }

    /* Ú©Ù†ØªØ±Ù„ Ù¾Ù„Ø§Ù†: Ø³ÙˆÛŒÛŒÚ† + Ø²ÙˆÙ… */
    const planToggleBtn = document.getElementById('planToggleBtn');
    const planZoomInBtn = document.getElementById('planZoomIn');
    const planZoomOutBtn = document.getElementById('planZoomOut');

    planToggleBtn.addEventListener('click', ()=>{
      showPlanFull = !showPlanFull;
      planToggleBtn.textContent = showPlanFull ? 'ğŸ‘ Ø³Ù‡â€ŒØ¨Ø¹Ø¯ÛŒ' : 'ğŸ‘ Ù¾Ù„Ø§Ù† Ú©ÙˆÚ†Ú©';
      if (showPlanFull){
        tctrl.detach();
        updateCoords(null);
        orbit.enabled = false;
        planControls.enabled = true;
      }else{
        planControls.enabled = false;
        orbit.enabled = true;
        if(selected){
          selectObject(selected, false);
        }
      }
    });

    planZoomInBtn.addEventListener('click', ()=>{
      applyPlanZoom(planZoom * 1.25);
    });

    planZoomOutBtn.addEventListener('click', ()=>{
      applyPlanZoom(planZoom / 1.25);
    });

    /* Ø²ÙˆÙ… Ù¾Ù„Ø§Ù† Ø¨Ø§ ÙˆÛŒÙ„ Ù…ÙˆØ³ */
    renderer.domElement.addEventListener('wheel',(e)=>{
      if (showPlanFull || isPointerInMiniPlan(e)){
        e.preventDefault();
        const scale = Math.exp(-e.deltaY * 0.001);
        applyPlanZoom(planZoom * scale);
      }
    }, { passive:false });

    /* Ø±Ù†Ø¯Ø± Ø¯Ùˆ Ù†Ù…Ø§ (Ø§ØµÙ„ÛŒ + Ù¾Ù„Ø§Ù†) Ø¨Ø§ Ø®Ø§Ù…ÙˆØ´ Ú©Ø±Ø¯Ù† Ø³Ø§ÛŒÙ‡ Ùˆ Ø®ÙˆØ±Ø´ÛŒØ¯ Ø¯Ø± Ù¾Ù„Ø§Ù† */
    function renderViews(){
      const w = window.innerWidth;
      const h = window.innerHeight;

      if (showPlanFull){
        setPlanHiddenSurfaces(true);
        setPlanHatching(true);

        const prevShadow = renderer.shadowMap.enabled;
        const prevSunIntensity = sunlight.intensity;
        const prevAmbientIntensity = ambient.intensity;

        renderer.shadowMap.enabled = false;
        sunlight.intensity = 0.0;
        ambient.intensity = 1.0;

        renderer.setViewport(0,0,w,h);
        renderer.setScissor(0,0,w,h);
        renderer.setScissorTest(true);
        renderer.render(scene, planCamera);
        renderer.setScissorTest(false);

        renderer.shadowMap.enabled = prevShadow;
        sunlight.intensity = prevSunIntensity;
        ambient.intensity = prevAmbientIntensity;

        setPlanHatching(false);
        setPlanHiddenSurfaces(false);
        return;
      }

      // Û±) Ù†Ù…Ø§ÛŒ Ø³Ù‡â€ŒØ¨Ø¹Ø¯ÛŒ Ø¨Ø§ Ø³Ø§ÛŒÙ‡ Ùˆ Ø®ÙˆØ±Ø´ÛŒØ¯
      setPlanHiddenSurfaces(false);
      setPlanHatching(false);
      renderer.shadowMap.enabled = true;
      renderer.setViewport(0,0,w,h);
      renderer.setScissor(0,0,w,h);
      renderer.setScissorTest(true);
      renderer.render(scene, camera);

      // Û²) Ù¾Ù„Ø§Ù† Ú©ÙˆÚ†Ú©ØŒ Ø¨Ø¯ÙˆÙ† Ø®ÙˆØ±Ø´ÛŒØ¯ Ùˆ Ø¨Ø§ Ù‡Ø§Ø´ÙˆØ±
      const size   = Math.min(w,h) * PLAN_REL_SIZE;
      const margin = PLAN_MARGIN;
      const vpX = margin;
      const vpY = margin;

      setPlanHiddenSurfaces(true);
      setPlanHatching(true);

      const prevShadow = renderer.shadowMap.enabled;
      const prevSunIntensity = sunlight.intensity;
      const prevAmbientIntensity = ambient.intensity;

      renderer.shadowMap.enabled = false;
      sunlight.intensity = 0.0;
      ambient.intensity = 1.0;

      renderer.setViewport(vpX,vpY,size,size);
      renderer.setScissor(vpX,vpY,size,size);
      renderer.setScissorTest(true);
      renderer.render(scene, planCamera);
      renderer.setScissorTest(false);

      renderer.shadowMap.enabled = prevShadow;
      sunlight.intensity = prevSunIntensity;
      ambient.intensity = prevAmbientIntensity;

      setPlanHatching(false);
      setPlanHiddenSurfaces(false);
    }

    /* ---------- Ø®Ø±ÙˆØ¬ÛŒ Ú¯Ø±ÙØªÙ† Ø§Ø² ÙˆÛŒÙˆ Ø¨Ù‡ ØµÙˆØ±Øª ØªØµÙˆÛŒØ± ---------- */
    function captureImage(scale = 2, format = 'png', bgMode = 'solid') {
      const w = window.innerWidth;
      const h = window.innerHeight;
      const width  = Math.floor(w * scale);
      const height = Math.floor(h * scale);

      const prevGridVisible   = grid.visible;
      const prevTctrlVisible  = tctrl.visible;

      const hiddenWires = [];
      scene.traverse(obj => {
        if (obj.name === '__wf__') {
          hiddenWires.push(obj);
          obj.visible = false;
        }
      });

      grid.visible  = false;
      tctrl.visible = false;

      const alpha = (bgMode === 'transparent');
      const exportRenderer = new THREE.WebGLRenderer({
        antialias: true,
        preserveDrawingBuffer: true,
        alpha
      });

      exportRenderer.setPixelRatio(1);
      exportRenderer.setSize(width, height, false);
      exportRenderer.shadowMap.enabled = true;
      exportRenderer.shadowMap.type = THREE.VSMShadowMap;

      if (bgMode === 'transparent'){
        exportRenderer.setClearColor(0x000000, 0);
      }else{
        exportRenderer.setClearColor(0xbcd2e8, 1);
      }

      const cam = showPlanFull ? planCamera : camera;

      if (showPlanFull) {
        setPlanHiddenSurfaces(true);
        setPlanHatching(true);

        const prevSun = sunlight.intensity;
        const prevAmb = ambient.intensity;
        sunlight.intensity = 0.0;
        ambient.intensity = 1.0;

        exportRenderer.render(scene, cam);

        sunlight.intensity = prevSun;
        ambient.intensity = prevAmb;

        setPlanHatching(false);
        setPlanHiddenSurfaces(false);
      } else {
        exportRenderer.render(scene, cam);
      }

      let mime = 'image/png';
      let ext  = 'png';
      if (format === 'jpg'){
        mime = 'image/jpeg';
        ext  = 'jpg';
      }

      const dataURL = exportRenderer.domElement.toDataURL(mime, 0.95);
      const link = document.createElement('a');
      link.href = dataURL;
      link.download = 'chidemana-view.'+ext;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

      exportRenderer.dispose();

      grid.visible  = prevGridVisible;
      tctrl.visible = prevTctrlVisible;
      hiddenWires.forEach(obj => { obj.visible = true; });
    }

    const renderDoBtn   = document.getElementById('renderDoBtn');
    const renderScaleEl = document.getElementById('renderScale');
    const renderFormatEl = document.getElementById('renderFormat');
    const renderBGEl     = document.getElementById('renderBG');

    if (renderDoBtn){
      renderDoBtn.addEventListener('click', ()=>{
        const scale  = parseFloat(renderScaleEl.value || '2') || 2;
        const format = (renderFormatEl.value || 'png').toLowerCase();
        const bgMode = (renderBGEl.value || 'solid');
        captureImage(scale, format, bgMode);
      });
    }

    /* Resize + Loop */
    window.addEventListener('resize',()=>{
      const w = window.innerWidth;
      const h = window.innerHeight;

      camera.aspect = w/h;
      camera.updateProjectionMatrix();

      updatePlanCameraFrustum();

      renderer.setSize(w,h);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
    });

    function animate(){
      const now=performance.now();
      if(camTween){
        const k=Math.min(1,(now-camTween.t0)/camTween.dur);
        const s=easeInOutQuad(k);
        camera.position.lerpVectors(camTween.fromPos,camTween.toPos,s);
        orbit.target.lerpVectors(camTween.fromTgt,camTween.toTarget,s);
        if(k>=1){
          camTween=null;
          orbit.enabled=true;
        }
      }
      orbit.update();
      planControls.update();

      renderViews();
      requestAnimationFrame(animate);
    }

    refreshPlanFloors();
    animate();
    updateHistoryButtons();
  </script>
</body>
</html>
